// @generated by protoc-gen-es v1.8.0
// @generated from file node/services/bifrost_rpc.proto (package co.topl.node.services, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { IoTransaction } from "../../brambl/models/transaction/io_transaction_pb.js";
import type { TransactionId } from "../../brambl/models/identifier_pb.js";
import type { BlockId } from "../../consensus/models/block_id_pb.js";
import type { BlockHeader } from "../../consensus/models/block_header_pb.js";
import type { BlockBody } from "../models/block_pb.js";
import type { NodeConfig } from "../models/node_config_pb.js";
import type { EpochData } from "../models/node_epochData_pb.js";

/**
 * Request type for BroadcastTransaction
 *
 * @generated from message co.topl.node.services.BroadcastTransactionReq
 */
export declare class BroadcastTransactionReq extends Message<BroadcastTransactionReq> {
  /**
   * A "proven" Transaction that is meant to be included in the blockchain
   *
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  constructor(data?: PartialMessage<BroadcastTransactionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.BroadcastTransactionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastTransactionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastTransactionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastTransactionReq;

  static equals(a: BroadcastTransactionReq | PlainMessage<BroadcastTransactionReq> | undefined, b: BroadcastTransactionReq | PlainMessage<BroadcastTransactionReq> | undefined): boolean;
}

/**
 * Response type for BroadcastTransaction
 *
 * @generated from message co.topl.node.services.BroadcastTransactionRes
 */
export declare class BroadcastTransactionRes extends Message<BroadcastTransactionRes> {
  constructor(data?: PartialMessage<BroadcastTransactionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.BroadcastTransactionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastTransactionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastTransactionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastTransactionRes;

  static equals(a: BroadcastTransactionRes | PlainMessage<BroadcastTransactionRes> | undefined, b: BroadcastTransactionRes | PlainMessage<BroadcastTransactionRes> | undefined): boolean;
}

/**
 * Request type for CurrentMempool
 *
 * @generated from message co.topl.node.services.CurrentMempoolReq
 */
export declare class CurrentMempoolReq extends Message<CurrentMempoolReq> {
  constructor(data?: PartialMessage<CurrentMempoolReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolReq;

  static equals(a: CurrentMempoolReq | PlainMessage<CurrentMempoolReq> | undefined, b: CurrentMempoolReq | PlainMessage<CurrentMempoolReq> | undefined): boolean;
}

/**
 * Response type for CurrentMempool
 *
 * @generated from message co.topl.node.services.CurrentMempoolRes
 */
export declare class CurrentMempoolRes extends Message<CurrentMempoolRes> {
  /**
   * A list of Transaction IDs that are currently in the node's mempool
   *
   * @generated from field: repeated co.topl.brambl.models.TransactionId transactionIds = 1;
   */
  transactionIds: TransactionId[];

  constructor(data?: PartialMessage<CurrentMempoolRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolRes;

  static equals(a: CurrentMempoolRes | PlainMessage<CurrentMempoolRes> | undefined, b: CurrentMempoolRes | PlainMessage<CurrentMempoolRes> | undefined): boolean;
}

/**
 * Request type for CurrentMempoolContainsReq
 *
 * @generated from message co.topl.node.services.CurrentMempoolContainsReq
 */
export declare class CurrentMempoolContainsReq extends Message<CurrentMempoolContainsReq> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionId transactionId = 1;
   */
  transactionId?: TransactionId;

  constructor(data?: PartialMessage<CurrentMempoolContainsReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolContainsReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolContainsReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolContainsReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolContainsReq;

  static equals(a: CurrentMempoolContainsReq | PlainMessage<CurrentMempoolContainsReq> | undefined, b: CurrentMempoolContainsReq | PlainMessage<CurrentMempoolContainsReq> | undefined): boolean;
}

/**
 * Response type for CurrentMempoolContainsRes
 *
 * @generated from message co.topl.node.services.CurrentMempoolContainsRes
 */
export declare class CurrentMempoolContainsRes extends Message<CurrentMempoolContainsRes> {
  /**
   * Predicate indicating if the Transaction ID is currently in the node's mempool
   *
   * @generated from field: bool inMempool = 1;
   */
  inMempool: boolean;

  constructor(data?: PartialMessage<CurrentMempoolContainsRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolContainsRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolContainsRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolContainsRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolContainsRes;

  static equals(a: CurrentMempoolContainsRes | PlainMessage<CurrentMempoolContainsRes> | undefined, b: CurrentMempoolContainsRes | PlainMessage<CurrentMempoolContainsRes> | undefined): boolean;
}

/**
 * Request type for FetchBlockHeader
 *
 * @generated from message co.topl.node.services.FetchBlockHeaderReq
 */
export declare class FetchBlockHeaderReq extends Message<FetchBlockHeaderReq> {
  /**
   * The ID of the block to retrieve
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockHeaderReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockHeaderReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockHeaderReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockHeaderReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockHeaderReq;

  static equals(a: FetchBlockHeaderReq | PlainMessage<FetchBlockHeaderReq> | undefined, b: FetchBlockHeaderReq | PlainMessage<FetchBlockHeaderReq> | undefined): boolean;
}

/**
 * Response type for FetchBlockHeader
 *
 * @generated from message co.topl.node.services.FetchBlockHeaderRes
 */
export declare class FetchBlockHeaderRes extends Message<FetchBlockHeaderRes> {
  /**
   * The Block Header associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockHeader header = 1;
   */
  header?: BlockHeader;

  constructor(data?: PartialMessage<FetchBlockHeaderRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockHeaderRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockHeaderRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockHeaderRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockHeaderRes;

  static equals(a: FetchBlockHeaderRes | PlainMessage<FetchBlockHeaderRes> | undefined, b: FetchBlockHeaderRes | PlainMessage<FetchBlockHeaderRes> | undefined): boolean;
}

/**
 * Request type for FetchBlockBody
 *
 * @generated from message co.topl.node.services.FetchBlockBodyReq
 */
export declare class FetchBlockBodyReq extends Message<FetchBlockBodyReq> {
  /**
   * The ID of the block to retrieve
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockBodyReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockBodyReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockBodyReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockBodyReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockBodyReq;

  static equals(a: FetchBlockBodyReq | PlainMessage<FetchBlockBodyReq> | undefined, b: FetchBlockBodyReq | PlainMessage<FetchBlockBodyReq> | undefined): boolean;
}

/**
 * Response type for FetchBlockBody
 *
 * @generated from message co.topl.node.services.FetchBlockBodyRes
 */
export declare class FetchBlockBodyRes extends Message<FetchBlockBodyRes> {
  /**
   * The Block Body associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.node.models.BlockBody body = 1;
   */
  body?: BlockBody;

  constructor(data?: PartialMessage<FetchBlockBodyRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockBodyRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockBodyRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockBodyRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockBodyRes;

  static equals(a: FetchBlockBodyRes | PlainMessage<FetchBlockBodyRes> | undefined, b: FetchBlockBodyRes | PlainMessage<FetchBlockBodyRes> | undefined): boolean;
}

/**
 * Request type for FetchTransaction
 *
 * @generated from message co.topl.node.services.FetchTransactionReq
 */
export declare class FetchTransactionReq extends Message<FetchTransactionReq> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionId transactionId = 1;
   */
  transactionId?: TransactionId;

  constructor(data?: PartialMessage<FetchTransactionReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchTransactionReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchTransactionReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchTransactionReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchTransactionReq;

  static equals(a: FetchTransactionReq | PlainMessage<FetchTransactionReq> | undefined, b: FetchTransactionReq | PlainMessage<FetchTransactionReq> | undefined): boolean;
}

/**
 * Response type for FetchTransaction
 *
 * @generated from message co.topl.node.services.FetchTransactionRes
 */
export declare class FetchTransactionRes extends Message<FetchTransactionRes> {
  /**
   * The Transaction associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  constructor(data?: PartialMessage<FetchTransactionRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchTransactionRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchTransactionRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchTransactionRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchTransactionRes;

  static equals(a: FetchTransactionRes | PlainMessage<FetchTransactionRes> | undefined, b: FetchTransactionRes | PlainMessage<FetchTransactionRes> | undefined): boolean;
}

/**
 * Request type for FetchBlockIdAtHeight
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtHeightReq
 */
export declare class FetchBlockIdAtHeightReq extends Message<FetchBlockIdAtHeightReq> {
  /**
   * The height of interest
   *
   * @generated from field: uint64 height = 1;
   */
  height: bigint;

  constructor(data?: PartialMessage<FetchBlockIdAtHeightReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtHeightReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtHeightReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightReq;

  static equals(a: FetchBlockIdAtHeightReq | PlainMessage<FetchBlockIdAtHeightReq> | undefined, b: FetchBlockIdAtHeightReq | PlainMessage<FetchBlockIdAtHeightReq> | undefined): boolean;
}

/**
 * Response type for FetchBlockIdAtHeight
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtHeightRes
 */
export declare class FetchBlockIdAtHeightRes extends Message<FetchBlockIdAtHeightRes> {
  /**
   * The Block ID associated with the requested height.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockIdAtHeightRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtHeightRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtHeightRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightRes;

  static equals(a: FetchBlockIdAtHeightRes | PlainMessage<FetchBlockIdAtHeightRes> | undefined, b: FetchBlockIdAtHeightRes | PlainMessage<FetchBlockIdAtHeightRes> | undefined): boolean;
}

/**
 * Request type for FetchBlockIdAtDepth
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtDepthReq
 */
export declare class FetchBlockIdAtDepthReq extends Message<FetchBlockIdAtDepthReq> {
  /**
   * The depth of interest.  When depth=0, the canonical head is retrieved.
   *
   * @generated from field: uint64 depth = 1;
   */
  depth: bigint;

  constructor(data?: PartialMessage<FetchBlockIdAtDepthReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtDepthReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtDepthReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthReq;

  static equals(a: FetchBlockIdAtDepthReq | PlainMessage<FetchBlockIdAtDepthReq> | undefined, b: FetchBlockIdAtDepthReq | PlainMessage<FetchBlockIdAtDepthReq> | undefined): boolean;
}

/**
 * Response type for FetchBlockIdAtDepth
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtDepthRes
 */
export declare class FetchBlockIdAtDepthRes extends Message<FetchBlockIdAtDepthRes> {
  /**
   * The Block ID associated with the requested depth.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockIdAtDepthRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtDepthRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtDepthRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthRes;

  static equals(a: FetchBlockIdAtDepthRes | PlainMessage<FetchBlockIdAtDepthRes> | undefined, b: FetchBlockIdAtDepthRes | PlainMessage<FetchBlockIdAtDepthRes> | undefined): boolean;
}

/**
 * Request type for SynchronizationTraversal
 *
 * @generated from message co.topl.node.services.SynchronizationTraversalReq
 */
export declare class SynchronizationTraversalReq extends Message<SynchronizationTraversalReq> {
  constructor(data?: PartialMessage<SynchronizationTraversalReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.SynchronizationTraversalReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SynchronizationTraversalReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SynchronizationTraversalReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SynchronizationTraversalReq;

  static equals(a: SynchronizationTraversalReq | PlainMessage<SynchronizationTraversalReq> | undefined, b: SynchronizationTraversalReq | PlainMessage<SynchronizationTraversalReq> | undefined): boolean;
}

/**
 * Response type for SynchronizationTraversal
 *
 * @generated from message co.topl.node.services.SynchronizationTraversalRes
 */
export declare class SynchronizationTraversalRes extends Message<SynchronizationTraversalRes> {
  /**
   * @generated from oneof co.topl.node.services.SynchronizationTraversalRes.status
   */
  status: {
    /**
     * Block ID applied
     *
     * @generated from field: co.topl.consensus.models.BlockId applied = 1;
     */
    value: BlockId;
    case: "applied";
  } | {
    /**
     * Block ID unapplied
     *
     * @generated from field: co.topl.consensus.models.BlockId unapplied = 2;
     */
    value: BlockId;
    case: "unapplied";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<SynchronizationTraversalRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.SynchronizationTraversalRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SynchronizationTraversalRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SynchronizationTraversalRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SynchronizationTraversalRes;

  static equals(a: SynchronizationTraversalRes | PlainMessage<SynchronizationTraversalRes> | undefined, b: SynchronizationTraversalRes | PlainMessage<SynchronizationTraversalRes> | undefined): boolean;
}

/**
 * Request type for FetchNodeConfigReq
 *
 * @generated from message co.topl.node.services.FetchNodeConfigReq
 */
export declare class FetchNodeConfigReq extends Message<FetchNodeConfigReq> {
  constructor(data?: PartialMessage<FetchNodeConfigReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchNodeConfigReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchNodeConfigReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchNodeConfigReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchNodeConfigReq;

  static equals(a: FetchNodeConfigReq | PlainMessage<FetchNodeConfigReq> | undefined, b: FetchNodeConfigReq | PlainMessage<FetchNodeConfigReq> | undefined): boolean;
}

/**
 * Response type for FetchNodeConfigRes
 *
 * @generated from message co.topl.node.services.FetchNodeConfigRes
 */
export declare class FetchNodeConfigRes extends Message<FetchNodeConfigRes> {
  /**
   * @generated from field: co.topl.proto.node.NodeConfig config = 1;
   */
  config?: NodeConfig;

  constructor(data?: PartialMessage<FetchNodeConfigRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchNodeConfigRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchNodeConfigRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchNodeConfigRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchNodeConfigRes;

  static equals(a: FetchNodeConfigRes | PlainMessage<FetchNodeConfigRes> | undefined, b: FetchNodeConfigRes | PlainMessage<FetchNodeConfigRes> | undefined): boolean;
}

/**
 * Request type for FetchEpochDataReq
 *
 * @generated from message co.topl.node.services.FetchEpochDataReq
 */
export declare class FetchEpochDataReq extends Message<FetchEpochDataReq> {
  /**
   * @generated from field: google.protobuf.UInt64Value epoch = 1;
   */
  epoch?: bigint;

  constructor(data?: PartialMessage<FetchEpochDataReq>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchEpochDataReq";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchEpochDataReq;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchEpochDataReq;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchEpochDataReq;

  static equals(a: FetchEpochDataReq | PlainMessage<FetchEpochDataReq> | undefined, b: FetchEpochDataReq | PlainMessage<FetchEpochDataReq> | undefined): boolean;
}

/**
 * Response type for FetchEpochDataRes
 *
 * @generated from message co.topl.node.services.FetchEpochDataRes
 */
export declare class FetchEpochDataRes extends Message<FetchEpochDataRes> {
  /**
   * @generated from field: co.topl.proto.node.EpochData epochData = 1;
   */
  epochData?: EpochData;

  constructor(data?: PartialMessage<FetchEpochDataRes>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.node.services.FetchEpochDataRes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchEpochDataRes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchEpochDataRes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchEpochDataRes;

  static equals(a: FetchEpochDataRes | PlainMessage<FetchEpochDataRes> | undefined, b: FetchEpochDataRes | PlainMessage<FetchEpochDataRes> | undefined): boolean;
}

