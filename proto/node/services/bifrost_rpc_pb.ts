// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file node/services/bifrost_rpc.proto (package co.topl.node.services, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, UInt64Value } from "@bufbuild/protobuf";
import { IoTransaction } from "../../brambl/models/transaction/io_transaction_pb.js";
import { TransactionId } from "../../brambl/models/identifier_pb.js";
import { BlockId } from "../../consensus/models/block_id_pb.js";
import { BlockHeader } from "../../consensus/models/block_header_pb.js";
import { BlockBody } from "../models/block_pb.js";
import { NodeConfig } from "../models/node_config_pb.js";
import { EpochData } from "../models/node_epochData_pb.js";

/**
 * Request type for BroadcastTransaction
 *
 * @generated from message co.topl.node.services.BroadcastTransactionReq
 */
export class BroadcastTransactionReq extends Message<BroadcastTransactionReq> {
  /**
   * A "proven" Transaction that is meant to be included in the blockchain
   *
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  constructor(data?: PartialMessage<BroadcastTransactionReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.BroadcastTransactionReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "message", T: IoTransaction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastTransactionReq {
    return new BroadcastTransactionReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastTransactionReq {
    return new BroadcastTransactionReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastTransactionReq {
    return new BroadcastTransactionReq().fromJsonString(jsonString, options);
  }

  static equals(a: BroadcastTransactionReq | PlainMessage<BroadcastTransactionReq> | undefined, b: BroadcastTransactionReq | PlainMessage<BroadcastTransactionReq> | undefined): boolean {
    return proto3.util.equals(BroadcastTransactionReq, a, b);
  }
}

/**
 * Response type for BroadcastTransaction
 *
 * @generated from message co.topl.node.services.BroadcastTransactionRes
 */
export class BroadcastTransactionRes extends Message<BroadcastTransactionRes> {
  constructor(data?: PartialMessage<BroadcastTransactionRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.BroadcastTransactionRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastTransactionRes {
    return new BroadcastTransactionRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastTransactionRes {
    return new BroadcastTransactionRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastTransactionRes {
    return new BroadcastTransactionRes().fromJsonString(jsonString, options);
  }

  static equals(a: BroadcastTransactionRes | PlainMessage<BroadcastTransactionRes> | undefined, b: BroadcastTransactionRes | PlainMessage<BroadcastTransactionRes> | undefined): boolean {
    return proto3.util.equals(BroadcastTransactionRes, a, b);
  }
}

/**
 * Request type for CurrentMempool
 *
 * @generated from message co.topl.node.services.CurrentMempoolReq
 */
export class CurrentMempoolReq extends Message<CurrentMempoolReq> {
  constructor(data?: PartialMessage<CurrentMempoolReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolReq {
    return new CurrentMempoolReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolReq {
    return new CurrentMempoolReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolReq {
    return new CurrentMempoolReq().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentMempoolReq | PlainMessage<CurrentMempoolReq> | undefined, b: CurrentMempoolReq | PlainMessage<CurrentMempoolReq> | undefined): boolean {
    return proto3.util.equals(CurrentMempoolReq, a, b);
  }
}

/**
 * Response type for CurrentMempool
 *
 * @generated from message co.topl.node.services.CurrentMempoolRes
 */
export class CurrentMempoolRes extends Message<CurrentMempoolRes> {
  /**
   * A list of Transaction IDs that are currently in the node's mempool
   *
   * @generated from field: repeated co.topl.brambl.models.TransactionId transactionIds = 1;
   */
  transactionIds: TransactionId[] = [];

  constructor(data?: PartialMessage<CurrentMempoolRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionIds", kind: "message", T: TransactionId, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolRes {
    return new CurrentMempoolRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolRes {
    return new CurrentMempoolRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolRes {
    return new CurrentMempoolRes().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentMempoolRes | PlainMessage<CurrentMempoolRes> | undefined, b: CurrentMempoolRes | PlainMessage<CurrentMempoolRes> | undefined): boolean {
    return proto3.util.equals(CurrentMempoolRes, a, b);
  }
}

/**
 * Request type for CurrentMempoolContainsReq
 *
 * @generated from message co.topl.node.services.CurrentMempoolContainsReq
 */
export class CurrentMempoolContainsReq extends Message<CurrentMempoolContainsReq> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionId transactionId = 1;
   */
  transactionId?: TransactionId;

  constructor(data?: PartialMessage<CurrentMempoolContainsReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolContainsReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionId", kind: "message", T: TransactionId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolContainsReq {
    return new CurrentMempoolContainsReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolContainsReq {
    return new CurrentMempoolContainsReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolContainsReq {
    return new CurrentMempoolContainsReq().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentMempoolContainsReq | PlainMessage<CurrentMempoolContainsReq> | undefined, b: CurrentMempoolContainsReq | PlainMessage<CurrentMempoolContainsReq> | undefined): boolean {
    return proto3.util.equals(CurrentMempoolContainsReq, a, b);
  }
}

/**
 * Response type for CurrentMempoolContainsRes
 *
 * @generated from message co.topl.node.services.CurrentMempoolContainsRes
 */
export class CurrentMempoolContainsRes extends Message<CurrentMempoolContainsRes> {
  /**
   * Predicate indicating if the Transaction ID is currently in the node's mempool
   *
   * @generated from field: bool inMempool = 1;
   */
  inMempool = false;

  constructor(data?: PartialMessage<CurrentMempoolContainsRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.CurrentMempoolContainsRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inMempool", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentMempoolContainsRes {
    return new CurrentMempoolContainsRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentMempoolContainsRes {
    return new CurrentMempoolContainsRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentMempoolContainsRes {
    return new CurrentMempoolContainsRes().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentMempoolContainsRes | PlainMessage<CurrentMempoolContainsRes> | undefined, b: CurrentMempoolContainsRes | PlainMessage<CurrentMempoolContainsRes> | undefined): boolean {
    return proto3.util.equals(CurrentMempoolContainsRes, a, b);
  }
}

/**
 * Request type for FetchBlockHeader
 *
 * @generated from message co.topl.node.services.FetchBlockHeaderReq
 */
export class FetchBlockHeaderReq extends Message<FetchBlockHeaderReq> {
  /**
   * The ID of the block to retrieve
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockHeaderReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockHeaderReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockId", kind: "message", T: BlockId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockHeaderReq {
    return new FetchBlockHeaderReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockHeaderReq {
    return new FetchBlockHeaderReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockHeaderReq {
    return new FetchBlockHeaderReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockHeaderReq | PlainMessage<FetchBlockHeaderReq> | undefined, b: FetchBlockHeaderReq | PlainMessage<FetchBlockHeaderReq> | undefined): boolean {
    return proto3.util.equals(FetchBlockHeaderReq, a, b);
  }
}

/**
 * Response type for FetchBlockHeader
 *
 * @generated from message co.topl.node.services.FetchBlockHeaderRes
 */
export class FetchBlockHeaderRes extends Message<FetchBlockHeaderRes> {
  /**
   * The Block Header associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockHeader header = 1;
   */
  header?: BlockHeader;

  constructor(data?: PartialMessage<FetchBlockHeaderRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockHeaderRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: BlockHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockHeaderRes {
    return new FetchBlockHeaderRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockHeaderRes {
    return new FetchBlockHeaderRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockHeaderRes {
    return new FetchBlockHeaderRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockHeaderRes | PlainMessage<FetchBlockHeaderRes> | undefined, b: FetchBlockHeaderRes | PlainMessage<FetchBlockHeaderRes> | undefined): boolean {
    return proto3.util.equals(FetchBlockHeaderRes, a, b);
  }
}

/**
 * Request type for FetchBlockBody
 *
 * @generated from message co.topl.node.services.FetchBlockBodyReq
 */
export class FetchBlockBodyReq extends Message<FetchBlockBodyReq> {
  /**
   * The ID of the block to retrieve
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockBodyReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockBodyReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockId", kind: "message", T: BlockId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockBodyReq {
    return new FetchBlockBodyReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockBodyReq {
    return new FetchBlockBodyReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockBodyReq {
    return new FetchBlockBodyReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockBodyReq | PlainMessage<FetchBlockBodyReq> | undefined, b: FetchBlockBodyReq | PlainMessage<FetchBlockBodyReq> | undefined): boolean {
    return proto3.util.equals(FetchBlockBodyReq, a, b);
  }
}

/**
 * Response type for FetchBlockBody
 *
 * @generated from message co.topl.node.services.FetchBlockBodyRes
 */
export class FetchBlockBodyRes extends Message<FetchBlockBodyRes> {
  /**
   * The Block Body associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.node.models.BlockBody body = 1;
   */
  body?: BlockBody;

  constructor(data?: PartialMessage<FetchBlockBodyRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockBodyRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "message", T: BlockBody },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockBodyRes {
    return new FetchBlockBodyRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockBodyRes {
    return new FetchBlockBodyRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockBodyRes {
    return new FetchBlockBodyRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockBodyRes | PlainMessage<FetchBlockBodyRes> | undefined, b: FetchBlockBodyRes | PlainMessage<FetchBlockBodyRes> | undefined): boolean {
    return proto3.util.equals(FetchBlockBodyRes, a, b);
  }
}

/**
 * Request type for FetchTransaction
 *
 * @generated from message co.topl.node.services.FetchTransactionReq
 */
export class FetchTransactionReq extends Message<FetchTransactionReq> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionId transactionId = 1;
   */
  transactionId?: TransactionId;

  constructor(data?: PartialMessage<FetchTransactionReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchTransactionReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionId", kind: "message", T: TransactionId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchTransactionReq {
    return new FetchTransactionReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchTransactionReq {
    return new FetchTransactionReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchTransactionReq {
    return new FetchTransactionReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchTransactionReq | PlainMessage<FetchTransactionReq> | undefined, b: FetchTransactionReq | PlainMessage<FetchTransactionReq> | undefined): boolean {
    return proto3.util.equals(FetchTransactionReq, a, b);
  }
}

/**
 * Response type for FetchTransaction
 *
 * @generated from message co.topl.node.services.FetchTransactionRes
 */
export class FetchTransactionRes extends Message<FetchTransactionRes> {
  /**
   * The Transaction associated with the requested ID.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  constructor(data?: PartialMessage<FetchTransactionRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchTransactionRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "message", T: IoTransaction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchTransactionRes {
    return new FetchTransactionRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchTransactionRes {
    return new FetchTransactionRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchTransactionRes {
    return new FetchTransactionRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchTransactionRes | PlainMessage<FetchTransactionRes> | undefined, b: FetchTransactionRes | PlainMessage<FetchTransactionRes> | undefined): boolean {
    return proto3.util.equals(FetchTransactionRes, a, b);
  }
}

/**
 * Request type for FetchBlockIdAtHeight
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtHeightReq
 */
export class FetchBlockIdAtHeightReq extends Message<FetchBlockIdAtHeightReq> {
  /**
   * The height of interest
   *
   * @generated from field: uint64 height = 1;
   */
  height = protoInt64.zero;

  constructor(data?: PartialMessage<FetchBlockIdAtHeightReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtHeightReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtHeightReq {
    return new FetchBlockIdAtHeightReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightReq {
    return new FetchBlockIdAtHeightReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightReq {
    return new FetchBlockIdAtHeightReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockIdAtHeightReq | PlainMessage<FetchBlockIdAtHeightReq> | undefined, b: FetchBlockIdAtHeightReq | PlainMessage<FetchBlockIdAtHeightReq> | undefined): boolean {
    return proto3.util.equals(FetchBlockIdAtHeightReq, a, b);
  }
}

/**
 * Response type for FetchBlockIdAtHeight
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtHeightRes
 */
export class FetchBlockIdAtHeightRes extends Message<FetchBlockIdAtHeightRes> {
  /**
   * The Block ID associated with the requested height.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockIdAtHeightRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtHeightRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockId", kind: "message", T: BlockId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtHeightRes {
    return new FetchBlockIdAtHeightRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightRes {
    return new FetchBlockIdAtHeightRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtHeightRes {
    return new FetchBlockIdAtHeightRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockIdAtHeightRes | PlainMessage<FetchBlockIdAtHeightRes> | undefined, b: FetchBlockIdAtHeightRes | PlainMessage<FetchBlockIdAtHeightRes> | undefined): boolean {
    return proto3.util.equals(FetchBlockIdAtHeightRes, a, b);
  }
}

/**
 * Request type for FetchBlockIdAtDepth
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtDepthReq
 */
export class FetchBlockIdAtDepthReq extends Message<FetchBlockIdAtDepthReq> {
  /**
   * The depth of interest.  When depth=0, the canonical head is retrieved.
   *
   * @generated from field: uint64 depth = 1;
   */
  depth = protoInt64.zero;

  constructor(data?: PartialMessage<FetchBlockIdAtDepthReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtDepthReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "depth", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtDepthReq {
    return new FetchBlockIdAtDepthReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthReq {
    return new FetchBlockIdAtDepthReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthReq {
    return new FetchBlockIdAtDepthReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockIdAtDepthReq | PlainMessage<FetchBlockIdAtDepthReq> | undefined, b: FetchBlockIdAtDepthReq | PlainMessage<FetchBlockIdAtDepthReq> | undefined): boolean {
    return proto3.util.equals(FetchBlockIdAtDepthReq, a, b);
  }
}

/**
 * Response type for FetchBlockIdAtDepth
 *
 * @generated from message co.topl.node.services.FetchBlockIdAtDepthRes
 */
export class FetchBlockIdAtDepthRes extends Message<FetchBlockIdAtDepthRes> {
  /**
   * The Block ID associated with the requested depth.  None/null if not found.
   * optional
   *
   * @generated from field: co.topl.consensus.models.BlockId blockId = 1;
   */
  blockId?: BlockId;

  constructor(data?: PartialMessage<FetchBlockIdAtDepthRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchBlockIdAtDepthRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockId", kind: "message", T: BlockId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchBlockIdAtDepthRes {
    return new FetchBlockIdAtDepthRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthRes {
    return new FetchBlockIdAtDepthRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchBlockIdAtDepthRes {
    return new FetchBlockIdAtDepthRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchBlockIdAtDepthRes | PlainMessage<FetchBlockIdAtDepthRes> | undefined, b: FetchBlockIdAtDepthRes | PlainMessage<FetchBlockIdAtDepthRes> | undefined): boolean {
    return proto3.util.equals(FetchBlockIdAtDepthRes, a, b);
  }
}

/**
 * Request type for SynchronizationTraversal
 *
 * @generated from message co.topl.node.services.SynchronizationTraversalReq
 */
export class SynchronizationTraversalReq extends Message<SynchronizationTraversalReq> {
  constructor(data?: PartialMessage<SynchronizationTraversalReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.SynchronizationTraversalReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SynchronizationTraversalReq {
    return new SynchronizationTraversalReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SynchronizationTraversalReq {
    return new SynchronizationTraversalReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SynchronizationTraversalReq {
    return new SynchronizationTraversalReq().fromJsonString(jsonString, options);
  }

  static equals(a: SynchronizationTraversalReq | PlainMessage<SynchronizationTraversalReq> | undefined, b: SynchronizationTraversalReq | PlainMessage<SynchronizationTraversalReq> | undefined): boolean {
    return proto3.util.equals(SynchronizationTraversalReq, a, b);
  }
}

/**
 * Response type for SynchronizationTraversal
 *
 * @generated from message co.topl.node.services.SynchronizationTraversalRes
 */
export class SynchronizationTraversalRes extends Message<SynchronizationTraversalRes> {
  /**
   * @generated from oneof co.topl.node.services.SynchronizationTraversalRes.status
   */
  status: {
    /**
     * Block ID applied
     *
     * @generated from field: co.topl.consensus.models.BlockId applied = 1;
     */
    value: BlockId;
    case: "applied";
  } | {
    /**
     * Block ID unapplied
     *
     * @generated from field: co.topl.consensus.models.BlockId unapplied = 2;
     */
    value: BlockId;
    case: "unapplied";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SynchronizationTraversalRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.SynchronizationTraversalRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied", kind: "message", T: BlockId, oneof: "status" },
    { no: 2, name: "unapplied", kind: "message", T: BlockId, oneof: "status" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SynchronizationTraversalRes {
    return new SynchronizationTraversalRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SynchronizationTraversalRes {
    return new SynchronizationTraversalRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SynchronizationTraversalRes {
    return new SynchronizationTraversalRes().fromJsonString(jsonString, options);
  }

  static equals(a: SynchronizationTraversalRes | PlainMessage<SynchronizationTraversalRes> | undefined, b: SynchronizationTraversalRes | PlainMessage<SynchronizationTraversalRes> | undefined): boolean {
    return proto3.util.equals(SynchronizationTraversalRes, a, b);
  }
}

/**
 * Request type for FetchNodeConfigReq
 *
 * @generated from message co.topl.node.services.FetchNodeConfigReq
 */
export class FetchNodeConfigReq extends Message<FetchNodeConfigReq> {
  constructor(data?: PartialMessage<FetchNodeConfigReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchNodeConfigReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchNodeConfigReq {
    return new FetchNodeConfigReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchNodeConfigReq {
    return new FetchNodeConfigReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchNodeConfigReq {
    return new FetchNodeConfigReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchNodeConfigReq | PlainMessage<FetchNodeConfigReq> | undefined, b: FetchNodeConfigReq | PlainMessage<FetchNodeConfigReq> | undefined): boolean {
    return proto3.util.equals(FetchNodeConfigReq, a, b);
  }
}

/**
 * Response type for FetchNodeConfigRes
 *
 * @generated from message co.topl.node.services.FetchNodeConfigRes
 */
export class FetchNodeConfigRes extends Message<FetchNodeConfigRes> {
  /**
   * @generated from field: co.topl.proto.node.NodeConfig config = 1;
   */
  config?: NodeConfig;

  constructor(data?: PartialMessage<FetchNodeConfigRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchNodeConfigRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: NodeConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchNodeConfigRes {
    return new FetchNodeConfigRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchNodeConfigRes {
    return new FetchNodeConfigRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchNodeConfigRes {
    return new FetchNodeConfigRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchNodeConfigRes | PlainMessage<FetchNodeConfigRes> | undefined, b: FetchNodeConfigRes | PlainMessage<FetchNodeConfigRes> | undefined): boolean {
    return proto3.util.equals(FetchNodeConfigRes, a, b);
  }
}

/**
 * Request type for FetchEpochDataReq
 *
 * @generated from message co.topl.node.services.FetchEpochDataReq
 */
export class FetchEpochDataReq extends Message<FetchEpochDataReq> {
  /**
   * @generated from field: google.protobuf.UInt64Value epoch = 1;
   */
  epoch?: bigint;

  constructor(data?: PartialMessage<FetchEpochDataReq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchEpochDataReq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "message", T: UInt64Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchEpochDataReq {
    return new FetchEpochDataReq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchEpochDataReq {
    return new FetchEpochDataReq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchEpochDataReq {
    return new FetchEpochDataReq().fromJsonString(jsonString, options);
  }

  static equals(a: FetchEpochDataReq | PlainMessage<FetchEpochDataReq> | undefined, b: FetchEpochDataReq | PlainMessage<FetchEpochDataReq> | undefined): boolean {
    return proto3.util.equals(FetchEpochDataReq, a, b);
  }
}

/**
 * Response type for FetchEpochDataRes
 *
 * @generated from message co.topl.node.services.FetchEpochDataRes
 */
export class FetchEpochDataRes extends Message<FetchEpochDataRes> {
  /**
   * @generated from field: co.topl.proto.node.EpochData epochData = 1;
   */
  epochData?: EpochData;

  constructor(data?: PartialMessage<FetchEpochDataRes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.node.services.FetchEpochDataRes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epochData", kind: "message", T: EpochData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchEpochDataRes {
    return new FetchEpochDataRes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchEpochDataRes {
    return new FetchEpochDataRes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchEpochDataRes {
    return new FetchEpochDataRes().fromJsonString(jsonString, options);
  }

  static equals(a: FetchEpochDataRes | PlainMessage<FetchEpochDataRes> | undefined, b: FetchEpochDataRes | PlainMessage<FetchEpochDataRes> | undefined): boolean {
    return proto3.util.equals(FetchEpochDataRes, a, b);
  }
}

