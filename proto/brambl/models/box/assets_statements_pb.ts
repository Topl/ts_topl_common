// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file brambl/models/box/assets_statements.proto (package co.topl.brambl.models.box, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct, UInt32Value } from "@bufbuild/protobuf";
import { TransactionOutputAddress } from "../address_pb.js";
import { Int128 } from "../../../quivr/models/shared_pb.js";

/**
 * @generated from message co.topl.brambl.models.box.AssetMintingStatement
 */
export class AssetMintingStatement extends Message<AssetMintingStatement> {
  /**
   * The address of the UTXO that contains the group constructor token that we are using to mint the asset token.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress groupTokenUtxo = 1;
   */
  groupTokenUtxo?: TransactionOutputAddress;

  /**
   * The address of the UTXO that contains the seriesconstructor token that we are using to mint the asset token.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress seriesTokenUtxo = 2;
   */
  seriesTokenUtxo?: TransactionOutputAddress;

  /**
   * The number of assets that we are minting using the group and series constructor token references by the two other attributes.
   *
   * @generated from field: quivr.models.Int128 quantity = 3;
   */
  quantity?: Int128;

  /**
   * This is the permanent metadata of an asset.
   * It follows the schema defined in the permanent metadata schema of the series policy corresponding to the token being minted.
   * The conformance of this field to the schema is not checked by the node.
   *
   * @generated from field: google.protobuf.Struct permanentMetadata = 4;
   */
  permanentMetadata?: Struct;

  constructor(data?: PartialMessage<AssetMintingStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetMintingStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupTokenUtxo", kind: "message", T: TransactionOutputAddress },
    { no: 2, name: "seriesTokenUtxo", kind: "message", T: TransactionOutputAddress },
    { no: 3, name: "quantity", kind: "message", T: Int128 },
    { no: 4, name: "permanentMetadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetMintingStatement {
    return new AssetMintingStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetMintingStatement {
    return new AssetMintingStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetMintingStatement {
    return new AssetMintingStatement().fromJsonString(jsonString, options);
  }

  static equals(a: AssetMintingStatement | PlainMessage<AssetMintingStatement> | undefined, b: AssetMintingStatement | PlainMessage<AssetMintingStatement> | undefined): boolean {
    return proto3.util.equals(AssetMintingStatement, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.box.AssetMergingStatement
 */
export class AssetMergingStatement extends Message<AssetMergingStatement> {
  /**
   * The non-empty list of UTXOs that we are using to compute the Merkle root for the alloy.
   *
   * @generated from field: repeated co.topl.brambl.models.TransactionOutputAddress inputUtxos = 1;
   */
  inputUtxos: TransactionOutputAddress[] = [];

  /**
   * The index in the output sequence of the transaction where the merged tokens are stored.
   *
   * @generated from field: uint32 outputIdx = 2;
   */
  outputIdx = 0;

  constructor(data?: PartialMessage<AssetMergingStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetMergingStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputUtxos", kind: "message", T: TransactionOutputAddress, repeated: true },
    { no: 2, name: "outputIdx", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetMergingStatement {
    return new AssetMergingStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetMergingStatement {
    return new AssetMergingStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetMergingStatement {
    return new AssetMergingStatement().fromJsonString(jsonString, options);
  }

  static equals(a: AssetMergingStatement | PlainMessage<AssetMergingStatement> | undefined, b: AssetMergingStatement | PlainMessage<AssetMergingStatement> | undefined): boolean {
    return proto3.util.equals(AssetMergingStatement, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.box.AssetSplittingStatement
 */
export class AssetSplittingStatement extends Message<AssetSplittingStatement> {
  /**
   * The non-empty list of indexes where the split asset is being put.
   *
   * @generated from field: repeated google.protobuf.UInt32Value outputIndexes = 1;
   */
  outputIndexes: UInt32Value[] = [];

  /**
   * The UTXO that is being split.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress inputUtxo = 2;
   */
  inputUtxo?: TransactionOutputAddress;

  constructor(data?: PartialMessage<AssetSplittingStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetSplittingStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "outputIndexes", kind: "message", T: UInt32Value, repeated: true },
    { no: 2, name: "inputUtxo", kind: "message", T: TransactionOutputAddress },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetSplittingStatement {
    return new AssetSplittingStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetSplittingStatement {
    return new AssetSplittingStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetSplittingStatement {
    return new AssetSplittingStatement().fromJsonString(jsonString, options);
  }

  static equals(a: AssetSplittingStatement | PlainMessage<AssetSplittingStatement> | undefined, b: AssetSplittingStatement | PlainMessage<AssetSplittingStatement> | undefined): boolean {
    return proto3.util.equals(AssetSplittingStatement, a, b);
  }
}

