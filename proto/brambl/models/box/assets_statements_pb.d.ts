// @generated by protoc-gen-es v1.8.0
// @generated from file brambl/models/box/assets_statements.proto (package co.topl.brambl.models.box, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct, UInt32Value } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { TransactionOutputAddress } from "../address_pb.js";
import type { Int128 } from "../../../quivr/models/shared_pb.js";

/**
 * @generated from message co.topl.brambl.models.box.AssetMintingStatement
 */
export declare class AssetMintingStatement extends Message<AssetMintingStatement> {
  /**
   * The address of the UTXO that contains the group constructor token that we are using to mint the asset token.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress groupTokenUtxo = 1;
   */
  groupTokenUtxo?: TransactionOutputAddress;

  /**
   * The address of the UTXO that contains the seriesconstructor token that we are using to mint the asset token.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress seriesTokenUtxo = 2;
   */
  seriesTokenUtxo?: TransactionOutputAddress;

  /**
   * The number of assets that we are minting using the group and series constructor token references by the two other attributes.
   *
   * @generated from field: quivr.models.Int128 quantity = 3;
   */
  quantity?: Int128;

  /**
   * This is the permanent metadata of an asset.
   * It follows the schema defined in the permanent metadata schema of the series policy corresponding to the token being minted.
   * The conformance of this field to the schema is not checked by the node.
   *
   * @generated from field: google.protobuf.Struct permanentMetadata = 4;
   */
  permanentMetadata?: Struct;

  constructor(data?: PartialMessage<AssetMintingStatement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetMintingStatement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetMintingStatement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetMintingStatement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetMintingStatement;

  static equals(a: AssetMintingStatement | PlainMessage<AssetMintingStatement> | undefined, b: AssetMintingStatement | PlainMessage<AssetMintingStatement> | undefined): boolean;
}

/**
 * @generated from message co.topl.brambl.models.box.AssetMergingStatement
 */
export declare class AssetMergingStatement extends Message<AssetMergingStatement> {
  /**
   * The non-empty list of UTXOs that we are using to compute the Merkle root for the alloy.
   *
   * @generated from field: repeated co.topl.brambl.models.TransactionOutputAddress inputUtxos = 1;
   */
  inputUtxos: TransactionOutputAddress[];

  /**
   * The index in the output sequence of the transaction where the merged tokens are stored.
   *
   * @generated from field: uint32 outputIdx = 2;
   */
  outputIdx: number;

  constructor(data?: PartialMessage<AssetMergingStatement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetMergingStatement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetMergingStatement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetMergingStatement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetMergingStatement;

  static equals(a: AssetMergingStatement | PlainMessage<AssetMergingStatement> | undefined, b: AssetMergingStatement | PlainMessage<AssetMergingStatement> | undefined): boolean;
}

/**
 * @generated from message co.topl.brambl.models.box.AssetSplittingStatement
 */
export declare class AssetSplittingStatement extends Message<AssetSplittingStatement> {
  /**
   * The non-empty list of indexes where the split asset is being put.
   *
   * @generated from field: repeated google.protobuf.UInt32Value outputIndexes = 1;
   */
  outputIndexes: UInt32Value[];

  /**
   * The UTXO that is being split.
   *
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress inputUtxo = 2;
   */
  inputUtxo?: TransactionOutputAddress;

  constructor(data?: PartialMessage<AssetSplittingStatement>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.brambl.models.box.AssetSplittingStatement";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetSplittingStatement;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetSplittingStatement;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetSplittingStatement;

  static equals(a: AssetSplittingStatement | PlainMessage<AssetSplittingStatement> | undefined, b: AssetSplittingStatement | PlainMessage<AssetSplittingStatement> | undefined): boolean;
}

