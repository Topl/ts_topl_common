// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file brambl/models/datum.proto (package co.topl.brambl.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Event_Eon, Event_Epoch, Event_Era, Event_GroupPolicy, Event_Header, Event_IoTransaction, Event_SeriesPolicy } from "./event_pb.js";

/**
 * Datums represent a queryable product value of the arguments available from a certain Event. Datum may be
 * evaluated during the Quivr protocol execution by providing events as Datum in a Dynamic Context.
 *
 * @generated from message co.topl.brambl.models.Datum
 */
export class Datum extends Message<Datum> {
  /**
   * @generated from oneof co.topl.brambl.models.Datum.value
   */
  value: {
    /**
     * @generated from field: co.topl.brambl.models.Datum.Eon eon = 1;
     */
    value: Datum_Eon;
    case: "eon";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.Era era = 2;
     */
    value: Datum_Era;
    case: "era";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.Epoch epoch = 3;
     */
    value: Datum_Epoch;
    case: "epoch";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.Header header = 4;
     */
    value: Datum_Header;
    case: "header";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.IoTransaction ioTransaction = 5;
     */
    value: Datum_IoTransaction;
    case: "ioTransaction";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.GroupPolicy groupPolicy = 6;
     */
    value: Datum_GroupPolicy;
    case: "groupPolicy";
  } | {
    /**
     * @generated from field: co.topl.brambl.models.Datum.SeriesPolicy seriesPolicy = 7;
     */
    value: Datum_SeriesPolicy;
    case: "seriesPolicy";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Datum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eon", kind: "message", T: Datum_Eon, oneof: "value" },
    { no: 2, name: "era", kind: "message", T: Datum_Era, oneof: "value" },
    { no: 3, name: "epoch", kind: "message", T: Datum_Epoch, oneof: "value" },
    { no: 4, name: "header", kind: "message", T: Datum_Header, oneof: "value" },
    { no: 5, name: "ioTransaction", kind: "message", T: Datum_IoTransaction, oneof: "value" },
    { no: 6, name: "groupPolicy", kind: "message", T: Datum_GroupPolicy, oneof: "value" },
    { no: 7, name: "seriesPolicy", kind: "message", T: Datum_SeriesPolicy, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum {
    return new Datum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum {
    return new Datum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum {
    return new Datum().fromJsonString(jsonString, options);
  }

  static equals(a: Datum | PlainMessage<Datum> | undefined, b: Datum | PlainMessage<Datum> | undefined): boolean {
    return proto3.util.equals(Datum, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.Eon
 */
export class Datum_Eon extends Message<Datum_Eon> {
  /**
   * @generated from field: co.topl.brambl.models.Event.Eon event = 1;
   */
  event?: Event_Eon;

  constructor(data?: PartialMessage<Datum_Eon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.Eon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_Eon },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_Eon {
    return new Datum_Eon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_Eon {
    return new Datum_Eon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_Eon {
    return new Datum_Eon().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_Eon | PlainMessage<Datum_Eon> | undefined, b: Datum_Eon | PlainMessage<Datum_Eon> | undefined): boolean {
    return proto3.util.equals(Datum_Eon, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.Era
 */
export class Datum_Era extends Message<Datum_Era> {
  /**
   * @generated from field: co.topl.brambl.models.Event.Era event = 1;
   */
  event?: Event_Era;

  constructor(data?: PartialMessage<Datum_Era>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.Era";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_Era },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_Era {
    return new Datum_Era().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_Era {
    return new Datum_Era().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_Era {
    return new Datum_Era().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_Era | PlainMessage<Datum_Era> | undefined, b: Datum_Era | PlainMessage<Datum_Era> | undefined): boolean {
    return proto3.util.equals(Datum_Era, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.Epoch
 */
export class Datum_Epoch extends Message<Datum_Epoch> {
  /**
   * @generated from field: co.topl.brambl.models.Event.Epoch event = 1;
   */
  event?: Event_Epoch;

  constructor(data?: PartialMessage<Datum_Epoch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.Epoch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_Epoch },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_Epoch {
    return new Datum_Epoch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_Epoch {
    return new Datum_Epoch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_Epoch {
    return new Datum_Epoch().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_Epoch | PlainMessage<Datum_Epoch> | undefined, b: Datum_Epoch | PlainMessage<Datum_Epoch> | undefined): boolean {
    return proto3.util.equals(Datum_Epoch, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.Header
 */
export class Datum_Header extends Message<Datum_Header> {
  /**
   * @generated from field: co.topl.brambl.models.Event.Header event = 1;
   */
  event?: Event_Header;

  constructor(data?: PartialMessage<Datum_Header>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.Header";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_Header },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_Header {
    return new Datum_Header().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_Header {
    return new Datum_Header().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_Header {
    return new Datum_Header().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_Header | PlainMessage<Datum_Header> | undefined, b: Datum_Header | PlainMessage<Datum_Header> | undefined): boolean {
    return proto3.util.equals(Datum_Header, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.IoTransaction
 */
export class Datum_IoTransaction extends Message<Datum_IoTransaction> {
  /**
   * @generated from field: co.topl.brambl.models.Event.IoTransaction event = 1;
   */
  event?: Event_IoTransaction;

  constructor(data?: PartialMessage<Datum_IoTransaction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.IoTransaction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_IoTransaction },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_IoTransaction {
    return new Datum_IoTransaction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_IoTransaction {
    return new Datum_IoTransaction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_IoTransaction {
    return new Datum_IoTransaction().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_IoTransaction | PlainMessage<Datum_IoTransaction> | undefined, b: Datum_IoTransaction | PlainMessage<Datum_IoTransaction> | undefined): boolean {
    return proto3.util.equals(Datum_IoTransaction, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.GroupPolicy
 */
export class Datum_GroupPolicy extends Message<Datum_GroupPolicy> {
  /**
   * @generated from field: co.topl.brambl.models.Event.GroupPolicy event = 1;
   */
  event?: Event_GroupPolicy;

  constructor(data?: PartialMessage<Datum_GroupPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.GroupPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_GroupPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_GroupPolicy {
    return new Datum_GroupPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_GroupPolicy {
    return new Datum_GroupPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_GroupPolicy {
    return new Datum_GroupPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_GroupPolicy | PlainMessage<Datum_GroupPolicy> | undefined, b: Datum_GroupPolicy | PlainMessage<Datum_GroupPolicy> | undefined): boolean {
    return proto3.util.equals(Datum_GroupPolicy, a, b);
  }
}

/**
 * @generated from message co.topl.brambl.models.Datum.SeriesPolicy
 */
export class Datum_SeriesPolicy extends Message<Datum_SeriesPolicy> {
  /**
   * @generated from field: co.topl.brambl.models.Event.SeriesPolicy event = 1;
   */
  event?: Event_SeriesPolicy;

  constructor(data?: PartialMessage<Datum_SeriesPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.brambl.models.Datum.SeriesPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: Event_SeriesPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Datum_SeriesPolicy {
    return new Datum_SeriesPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Datum_SeriesPolicy {
    return new Datum_SeriesPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Datum_SeriesPolicy {
    return new Datum_SeriesPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: Datum_SeriesPolicy | PlainMessage<Datum_SeriesPolicy> | undefined, b: Datum_SeriesPolicy | PlainMessage<Datum_SeriesPolicy> | undefined): boolean {
    return proto3.util.equals(Datum_SeriesPolicy, a, b);
  }
}

