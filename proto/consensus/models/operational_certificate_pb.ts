// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file consensus/models/operational_certificate.proto (package co.topl.consensus.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * A certificate which commits an operator to a linear key, which is then used to sign the block
 *
 * @generated from message co.topl.consensus.models.OperationalCertificate
 */
export class OperationalCertificate extends Message<OperationalCertificate> {
  /**
   * The KES VK of the parent key (forward-secure) (hour+minute hands)
   *
   * @generated from field: co.topl.consensus.models.VerificationKeyKesProduct parentVK = 1;
   */
  parentVK?: VerificationKeyKesProduct;

  /**
   * Signs the `childVK` using the `parentSK`
   *
   * @generated from field: co.topl.consensus.models.SignatureKesProduct parentSignature = 2;
   */
  parentSignature?: SignatureKesProduct;

  /**
   * The linear VK
   *
   * @generated from field: bytes childVK = 3;
   */
  childVK = new Uint8Array(0);

  /**
   * The signature of the block
   *
   * @generated from field: bytes childSignature = 4;
   */
  childSignature = new Uint8Array(0);

  constructor(data?: PartialMessage<OperationalCertificate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.consensus.models.OperationalCertificate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parentVK", kind: "message", T: VerificationKeyKesProduct },
    { no: 2, name: "parentSignature", kind: "message", T: SignatureKesProduct },
    { no: 3, name: "childVK", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "childSignature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperationalCertificate {
    return new OperationalCertificate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperationalCertificate {
    return new OperationalCertificate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperationalCertificate {
    return new OperationalCertificate().fromJsonString(jsonString, options);
  }

  static equals(a: OperationalCertificate | PlainMessage<OperationalCertificate> | undefined, b: OperationalCertificate | PlainMessage<OperationalCertificate> | undefined): boolean {
    return proto3.util.equals(OperationalCertificate, a, b);
  }
}

/**
 * @generated from message co.topl.consensus.models.VerificationKeyKesProduct
 */
export class VerificationKeyKesProduct extends Message<VerificationKeyKesProduct> {
  /**
   * length = 32
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  /**
   * @generated from field: uint32 step = 2;
   */
  step = 0;

  constructor(data?: PartialMessage<VerificationKeyKesProduct>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.consensus.models.VerificationKeyKesProduct";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "step", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationKeyKesProduct {
    return new VerificationKeyKesProduct().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationKeyKesProduct {
    return new VerificationKeyKesProduct().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationKeyKesProduct {
    return new VerificationKeyKesProduct().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationKeyKesProduct | PlainMessage<VerificationKeyKesProduct> | undefined, b: VerificationKeyKesProduct | PlainMessage<VerificationKeyKesProduct> | undefined): boolean {
    return proto3.util.equals(VerificationKeyKesProduct, a, b);
  }
}

/**
 * @generated from message co.topl.consensus.models.SignatureKesSum
 */
export class SignatureKesSum extends Message<SignatureKesSum> {
  /**
   * @generated from field: bytes verificationKey = 1;
   */
  verificationKey = new Uint8Array(0);

  /**
   * @generated from field: bytes signature = 2;
   */
  signature = new Uint8Array(0);

  /**
   * item length = 32
   *
   * @generated from field: repeated bytes witness = 3;
   */
  witness: Uint8Array[] = [];

  constructor(data?: PartialMessage<SignatureKesSum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.consensus.models.SignatureKesSum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verificationKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "witness", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignatureKesSum {
    return new SignatureKesSum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignatureKesSum {
    return new SignatureKesSum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignatureKesSum {
    return new SignatureKesSum().fromJsonString(jsonString, options);
  }

  static equals(a: SignatureKesSum | PlainMessage<SignatureKesSum> | undefined, b: SignatureKesSum | PlainMessage<SignatureKesSum> | undefined): boolean {
    return proto3.util.equals(SignatureKesSum, a, b);
  }
}

/**
 * @generated from message co.topl.consensus.models.SignatureKesProduct
 */
export class SignatureKesProduct extends Message<SignatureKesProduct> {
  /**
   * @generated from field: co.topl.consensus.models.SignatureKesSum superSignature = 1;
   */
  superSignature?: SignatureKesSum;

  /**
   * @generated from field: co.topl.consensus.models.SignatureKesSum subSignature = 2;
   */
  subSignature?: SignatureKesSum;

  /**
   * length = 32
   *
   * @generated from field: bytes subRoot = 3;
   */
  subRoot = new Uint8Array(0);

  constructor(data?: PartialMessage<SignatureKesProduct>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.consensus.models.SignatureKesProduct";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "superSignature", kind: "message", T: SignatureKesSum },
    { no: 2, name: "subSignature", kind: "message", T: SignatureKesSum },
    { no: 3, name: "subRoot", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignatureKesProduct {
    return new SignatureKesProduct().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignatureKesProduct {
    return new SignatureKesProduct().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignatureKesProduct {
    return new SignatureKesProduct().fromJsonString(jsonString, options);
  }

  static equals(a: SignatureKesProduct | PlainMessage<SignatureKesProduct> | undefined, b: SignatureKesProduct | PlainMessage<SignatureKesProduct> | undefined): boolean {
    return proto3.util.equals(SignatureKesProduct, a, b);
  }
}

