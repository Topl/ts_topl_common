// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file genus/genus_models.proto (package co.topl.genus.services, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, UInt32Value } from "@bufbuild/protobuf";
import { UnspentTransactionOutput } from "../brambl/models/transaction/unspent_transaction_output_pb.js";
import { LockAddress, TransactionInputAddress, TransactionOutputAddress } from "../brambl/models/address_pb.js";
import { SpentTransactionOutput } from "../brambl/models/transaction/spent_transaction_output_pb.js";
import { IoTransaction } from "../brambl/models/transaction/io_transaction_pb.js";
import { BlockId } from "../consensus/models/block_id_pb.js";
import { BlockHeader } from "../consensus/models/block_header_pb.js";
import { FullBlockBody } from "../node/models/block_pb.js";

/**
 * Used to identify the status of a Txo.
 *
 * @generated from enum co.topl.genus.services.TxoState
 */
export enum TxoState {
  /**
   * The TxO is spent
   *
   * @generated from enum value: SPENT = 0;
   */
  SPENT = 0,

  /**
   * The TxO is not spent
   *
   * @generated from enum value: UNSPENT = 1;
   */
  UNSPENT = 1,

  /**
   * A transaction is pending that may spend the TXO. This state should only appear in bifrost clients.
   *
   * @generated from enum value: PENDING = 2;
   */
  PENDING = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TxoState)
proto3.util.setEnumType(TxoState, "co.topl.genus.services.TxoState", [
  { no: 0, name: "SPENT" },
  { no: 1, name: "UNSPENT" },
  { no: 2, name: "PENDING" },
]);

/**
 * Specify the order of data for indexes.
 *
 * @generated from enum co.topl.genus.services.SortOrder
 */
export enum SortOrder {
  /**
   * @generated from enum value: ASCENDING = 0;
   */
  ASCENDING = 0,

  /**
   * @generated from enum value: DESCENDING = 1;
   */
  DESCENDING = 1,

  /**
   * @generated from enum value: UNSORTED = 2;
   */
  UNSORTED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOrder)
proto3.util.setEnumType(SortOrder, "co.topl.genus.services.SortOrder", [
  { no: 0, name: "ASCENDING" },
  { no: 1, name: "DESCENDING" },
  { no: 2, name: "UNSORTED" },
]);

/**
 * Types of assets that can be identified by an AssetLabel
 *
 * @generated from enum co.topl.genus.services.LabelType
 */
export enum LabelType {
  /**
   * @generated from enum value: EMPTY = 0;
   */
  EMPTY = 0,

  /**
   * @generated from enum value: LVL = 1;
   */
  LVL = 1,

  /**
   * @generated from enum value: TOPL = 2;
   */
  TOPL = 2,

  /**
   * @generated from enum value: V1 = 3;
   */
  V1 = 3,

  /**
   * @generated from enum value: TAM2 = 4;
   */
  TAM2 = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(LabelType)
proto3.util.setEnumType(LabelType, "co.topl.genus.services.LabelType", [
  { no: 0, name: "EMPTY" },
  { no: 1, name: "LVL" },
  { no: 2, name: "TOPL" },
  { no: 3, name: "V1" },
  { no: 4, name: "TAM2" },
]);

/**
 * A Txo and its status
 *
 * @generated from message co.topl.genus.services.Txo
 */
export class Txo extends Message<Txo> {
  /**
   * @generated from field: co.topl.brambl.models.transaction.UnspentTransactionOutput transactionOutput = 1;
   */
  transactionOutput?: UnspentTransactionOutput;

  /**
   * @generated from field: co.topl.genus.services.TxoState state = 2;
   */
  state = TxoState.SPENT;

  /**
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress outputAddress = 3;
   */
  outputAddress?: TransactionOutputAddress;

  /**
   * When 'state' is "SPENT", this field points to the transaction (input) that spent it.
   * Otherwise, this field is empty.
   *
   * @generated from field: co.topl.genus.services.Txo.Spender spender = 4;
   */
  spender?: Txo_Spender;

  constructor(data?: PartialMessage<Txo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.Txo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionOutput", kind: "message", T: UnspentTransactionOutput },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(TxoState) },
    { no: 3, name: "outputAddress", kind: "message", T: TransactionOutputAddress },
    { no: 4, name: "spender", kind: "message", T: Txo_Spender },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Txo {
    return new Txo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Txo {
    return new Txo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Txo {
    return new Txo().fromJsonString(jsonString, options);
  }

  static equals(a: Txo | PlainMessage<Txo> | undefined, b: Txo | PlainMessage<Txo> | undefined): boolean {
    return proto3.util.equals(Txo, a, b);
  }
}

/**
 * @generated from message co.topl.genus.services.Txo.Spender
 */
export class Txo_Spender extends Message<Txo_Spender> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionInputAddress inputAddress = 1;
   */
  inputAddress?: TransactionInputAddress;

  /**
   * @generated from field: co.topl.brambl.models.transaction.SpentTransactionOutput input = 2;
   */
  input?: SpentTransactionOutput;

  constructor(data?: PartialMessage<Txo_Spender>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.Txo.Spender";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputAddress", kind: "message", T: TransactionInputAddress },
    { no: 2, name: "input", kind: "message", T: SpentTransactionOutput },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Txo_Spender {
    return new Txo_Spender().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Txo_Spender {
    return new Txo_Spender().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Txo_Spender {
    return new Txo_Spender().fromJsonString(jsonString, options);
  }

  static equals(a: Txo_Spender | PlainMessage<Txo_Spender> | undefined, b: Txo_Spender | PlainMessage<Txo_Spender> | undefined): boolean {
    return proto3.util.equals(Txo_Spender, a, b);
  }
}

/**
 * 1 - the probability that something will be subject to a reorg.
 * Defaults to 0.9999999
 *
 * @generated from message co.topl.genus.services.ConfidenceFactor
 */
export class ConfidenceFactor extends Message<ConfidenceFactor> {
  /**
   * @generated from field: double value = 1;
   */
  value = 0;

  constructor(data?: PartialMessage<ConfidenceFactor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.ConfidenceFactor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfidenceFactor {
    return new ConfidenceFactor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfidenceFactor {
    return new ConfidenceFactor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfidenceFactor {
    return new ConfidenceFactor().fromJsonString(jsonString, options);
  }

  static equals(a: ConfidenceFactor | PlainMessage<ConfidenceFactor> | undefined, b: ConfidenceFactor | PlainMessage<ConfidenceFactor> | undefined): boolean {
    return proto3.util.equals(ConfidenceFactor, a, b);
  }
}

/**
 * The distance between blocks
 *
 * @generated from message co.topl.genus.services.ChainDistance
 */
export class ChainDistance extends Message<ChainDistance> {
  /**
   * @generated from field: int64 value = 1;
   */
  value = protoInt64.zero;

  constructor(data?: PartialMessage<ChainDistance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.ChainDistance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainDistance {
    return new ChainDistance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainDistance {
    return new ChainDistance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainDistance {
    return new ChainDistance().fromJsonString(jsonString, options);
  }

  static equals(a: ChainDistance | PlainMessage<ChainDistance> | undefined, b: ChainDistance | PlainMessage<ChainDistance> | undefined): boolean {
    return proto3.util.equals(ChainDistance, a, b);
  }
}

/**
 * An identifier for a TAM2 asset type
 *
 * @generated from message co.topl.genus.services.AssetLabel
 */
export class AssetLabel extends Message<AssetLabel> {
  /**
   * @generated from field: co.topl.genus.services.LabelType labelType = 1;
   */
  labelType = LabelType.EMPTY;

  /**
   * @generated from oneof co.topl.genus.services.AssetLabel.label
   */
  label: {
    /**
     * Since this is a one-of we need to have a field to use for the label types such as LVL that don't need them.
     *
     * @generated from field: co.topl.genus.services.AssetLabel.Empty empty = 2;
     */
    value: AssetLabel_Empty;
    case: "empty";
  } | {
    /**
     * @generated from field: co.topl.genus.services.AssetLabel.V1Label v1Label = 3;
     */
    value: AssetLabel_V1Label;
    case: "v1Label";
  } | {
    /**
     * @generated from field: co.topl.genus.services.AssetLabel.Tam2Label tam2Label = 4;
     */
    value: AssetLabel_Tam2Label;
    case: "tam2Label";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AssetLabel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labelType", kind: "enum", T: proto3.getEnumType(LabelType) },
    { no: 2, name: "empty", kind: "message", T: AssetLabel_Empty, oneof: "label" },
    { no: 3, name: "v1Label", kind: "message", T: AssetLabel_V1Label, oneof: "label" },
    { no: 4, name: "tam2Label", kind: "message", T: AssetLabel_Tam2Label, oneof: "label" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel {
    return new AssetLabel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel {
    return new AssetLabel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel {
    return new AssetLabel().fromJsonString(jsonString, options);
  }

  static equals(a: AssetLabel | PlainMessage<AssetLabel> | undefined, b: AssetLabel | PlainMessage<AssetLabel> | undefined): boolean {
    return proto3.util.equals(AssetLabel, a, b);
  }
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.Empty
 */
export class AssetLabel_Empty extends Message<AssetLabel_Empty> {
  constructor(data?: PartialMessage<AssetLabel_Empty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.Empty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_Empty {
    return new AssetLabel_Empty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_Empty {
    return new AssetLabel_Empty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_Empty {
    return new AssetLabel_Empty().fromJsonString(jsonString, options);
  }

  static equals(a: AssetLabel_Empty | PlainMessage<AssetLabel_Empty> | undefined, b: AssetLabel_Empty | PlainMessage<AssetLabel_Empty> | undefined): boolean {
    return proto3.util.equals(AssetLabel_Empty, a, b);
  }
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.V1Label
 */
export class AssetLabel_V1Label extends Message<AssetLabel_V1Label> {
  /**
   * @generated from field: uint32 version = 1;
   */
  version = 0;

  /**
   * @generated from field: co.topl.brambl.models.LockAddress mintingAddress = 2;
   */
  mintingAddress?: LockAddress;

  constructor(data?: PartialMessage<AssetLabel_V1Label>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.V1Label";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "mintingAddress", kind: "message", T: LockAddress },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_V1Label {
    return new AssetLabel_V1Label().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_V1Label {
    return new AssetLabel_V1Label().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_V1Label {
    return new AssetLabel_V1Label().fromJsonString(jsonString, options);
  }

  static equals(a: AssetLabel_V1Label | PlainMessage<AssetLabel_V1Label> | undefined, b: AssetLabel_V1Label | PlainMessage<AssetLabel_V1Label> | undefined): boolean {
    return proto3.util.equals(AssetLabel_V1Label, a, b);
  }
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.Tam2Label
 */
export class AssetLabel_Tam2Label extends Message<AssetLabel_Tam2Label> {
  /**
   * @generated from field: fixed64 groupHashMostSignificant = 1;
   */
  groupHashMostSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 groupHashMoreSignificant = 2;
   */
  groupHashMoreSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 groupHashLessSignificant = 3;
   */
  groupHashLessSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 groupHashLeastSignificant = 4;
   */
  groupHashLeastSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 seriesHashMostSignificant = 5;
   */
  seriesHashMostSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 seriesHashMoreSignificant = 6;
   */
  seriesHashMoreSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 seriesHashLessSignificant = 7;
   */
  seriesHashLessSignificant = protoInt64.zero;

  /**
   * @generated from field: fixed64 seriesHashLeastSignificant = 8;
   */
  seriesHashLeastSignificant = protoInt64.zero;

  constructor(data?: PartialMessage<AssetLabel_Tam2Label>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.Tam2Label";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupHashMostSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 2, name: "groupHashMoreSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "groupHashLessSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "groupHashLeastSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 5, name: "seriesHashMostSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 6, name: "seriesHashMoreSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 7, name: "seriesHashLessSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 8, name: "seriesHashLeastSignificant", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_Tam2Label {
    return new AssetLabel_Tam2Label().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_Tam2Label {
    return new AssetLabel_Tam2Label().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_Tam2Label {
    return new AssetLabel_Tam2Label().fromJsonString(jsonString, options);
  }

  static equals(a: AssetLabel_Tam2Label | PlainMessage<AssetLabel_Tam2Label> | undefined, b: AssetLabel_Tam2Label | PlainMessage<AssetLabel_Tam2Label> | undefined): boolean {
    return proto3.util.equals(AssetLabel_Tam2Label, a, b);
  }
}

/**
 * A request to create an index of transaction based on their on-chain metadata
 *
 * @generated from message co.topl.genus.services.IndexSpec
 */
export class IndexSpec extends Message<IndexSpec> {
  /**
   * The name of the index
   *
   * @generated from field: string indexName = 1;
   */
  indexName = "";

  /**
   * A description of the fields to be indexed
   *
   * @generated from field: co.topl.genus.services.IndexFieldSpec indexFieldSpec = 2;
   */
  indexFieldSpec?: IndexFieldSpec;

  /**
   * Filter to determine which transactions are included in the index. Only records that match the filter will be included in the index.
   *
   * @generated from field: co.topl.genus.services.IndexFilter indexFilter = 3;
   */
  indexFilter?: IndexFilter;

  constructor(data?: PartialMessage<IndexSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.IndexSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "indexName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "indexFieldSpec", kind: "message", T: IndexFieldSpec },
    { no: 3, name: "indexFilter", kind: "message", T: IndexFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexSpec {
    return new IndexSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexSpec {
    return new IndexSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexSpec {
    return new IndexSpec().fromJsonString(jsonString, options);
  }

  static equals(a: IndexSpec | PlainMessage<IndexSpec> | undefined, b: IndexSpec | PlainMessage<IndexSpec> | undefined): boolean {
    return proto3.util.equals(IndexSpec, a, b);
  }
}

/**
 * A specification to identify the field(s) in data to be indexed
 *
 * @generated from message co.topl.genus.services.IndexFieldSpec
 */
export class IndexFieldSpec extends Message<IndexFieldSpec> {
  /**
   * @generated from oneof co.topl.genus.services.IndexFieldSpec.spec
   */
  spec: {
    /**
     * @generated from field: co.topl.genus.services.JsonIndexSpecs jsonSpecs = 1;
     */
    value: JsonIndexSpecs;
    case: "jsonSpecs";
  } | {
    /**
     * TODO ways to specify indexes for other types of data
     *
     * @generated from field: co.topl.genus.services.CsvIndexSpecs csvSpecs = 2;
     */
    value: CsvIndexSpecs;
    case: "csvSpecs";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IndexFieldSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.IndexFieldSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jsonSpecs", kind: "message", T: JsonIndexSpecs, oneof: "spec" },
    { no: 2, name: "csvSpecs", kind: "message", T: CsvIndexSpecs, oneof: "spec" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexFieldSpec {
    return new IndexFieldSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexFieldSpec {
    return new IndexFieldSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexFieldSpec {
    return new IndexFieldSpec().fromJsonString(jsonString, options);
  }

  static equals(a: IndexFieldSpec | PlainMessage<IndexFieldSpec> | undefined, b: IndexFieldSpec | PlainMessage<IndexFieldSpec> | undefined): boolean {
    return proto3.util.equals(IndexFieldSpec, a, b);
  }
}

/**
 * a sequence of csv field references to identify the values in data to be indexed
 *
 * @generated from message co.topl.genus.services.CsvIndexSpecs
 */
export class CsvIndexSpecs extends Message<CsvIndexSpecs> {
  /**
   * @generated from field: repeated co.topl.genus.services.CsvIndexSpec specs = 1;
   */
  specs: CsvIndexSpec[] = [];

  /**
   * The character code that is used to separate fields.
   *
   * @generated from field: uint32 separatorChar = 2;
   */
  separatorChar = 0;

  /**
   * If this is present, the specified character appears at the beginning and end of each field.
   *
   * @generated from field: google.protobuf.UInt32Value quoteChar = 3;
   */
  quoteChar?: number;

  constructor(data?: PartialMessage<CsvIndexSpecs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.CsvIndexSpecs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "specs", kind: "message", T: CsvIndexSpec, repeated: true },
    { no: 2, name: "separatorChar", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "quoteChar", kind: "message", T: UInt32Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CsvIndexSpecs {
    return new CsvIndexSpecs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CsvIndexSpecs {
    return new CsvIndexSpecs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CsvIndexSpecs {
    return new CsvIndexSpecs().fromJsonString(jsonString, options);
  }

  static equals(a: CsvIndexSpecs | PlainMessage<CsvIndexSpecs> | undefined, b: CsvIndexSpecs | PlainMessage<CsvIndexSpecs> | undefined): boolean {
    return proto3.util.equals(CsvIndexSpecs, a, b);
  }
}

/**
 * a sequence of csv field references to identify the values in data to be indexed
 *
 * @generated from message co.topl.genus.services.CsvIndexSpec
 */
export class CsvIndexSpec extends Message<CsvIndexSpec> {
  /**
   * Origin 1 field index
   *
   * @generated from field: uint32 fieldIndex = 1;
   */
  fieldIndex = 0;

  /**
   * @generated from field: co.topl.genus.services.SortOrder sortOrder = 2;
   */
  sortOrder = SortOrder.ASCENDING;

  /**
   * If this is true, the field is sorted numerically; otherwise lexically.
   *
   * @generated from field: bool isNumeric = 3;
   */
  isNumeric = false;

  constructor(data?: PartialMessage<CsvIndexSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.CsvIndexSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fieldIndex", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "sortOrder", kind: "enum", T: proto3.getEnumType(SortOrder) },
    { no: 3, name: "isNumeric", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CsvIndexSpec {
    return new CsvIndexSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CsvIndexSpec {
    return new CsvIndexSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CsvIndexSpec {
    return new CsvIndexSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CsvIndexSpec | PlainMessage<CsvIndexSpec> | undefined, b: CsvIndexSpec | PlainMessage<CsvIndexSpec> | undefined): boolean {
    return proto3.util.equals(CsvIndexSpec, a, b);
  }
}

/**
 * A sequence of JSONPath strings to identify the values in data to be indexed (https://datatracker.ietf.org/doc/id/draft-goessner-dispatch-jsonpath-00.html)
 *
 * @generated from message co.topl.genus.services.JsonIndexSpecs
 */
export class JsonIndexSpecs extends Message<JsonIndexSpecs> {
  /**
   * @generated from field: repeated co.topl.genus.services.JsonIndexSpec specs = 1;
   */
  specs: JsonIndexSpec[] = [];

  constructor(data?: PartialMessage<JsonIndexSpecs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.JsonIndexSpecs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "specs", kind: "message", T: JsonIndexSpec, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JsonIndexSpecs {
    return new JsonIndexSpecs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JsonIndexSpecs {
    return new JsonIndexSpecs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JsonIndexSpecs {
    return new JsonIndexSpecs().fromJsonString(jsonString, options);
  }

  static equals(a: JsonIndexSpecs | PlainMessage<JsonIndexSpecs> | undefined, b: JsonIndexSpecs | PlainMessage<JsonIndexSpecs> | undefined): boolean {
    return proto3.util.equals(JsonIndexSpecs, a, b);
  }
}

/**
 * A JSONPath string to identify a value in data to be indexed (https://datatracker.ietf.org/doc/id/draft-goessner-dispatch-jsonpath-00.html)
 *
 * @generated from message co.topl.genus.services.JsonIndexSpec
 */
export class JsonIndexSpec extends Message<JsonIndexSpec> {
  /**
   * @generated from field: string jsonPath = 1;
   */
  jsonPath = "";

  /**
   * @generated from field: co.topl.genus.services.SortOrder sortOrder = 2;
   */
  sortOrder = SortOrder.ASCENDING;

  constructor(data?: PartialMessage<JsonIndexSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.JsonIndexSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jsonPath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sortOrder", kind: "enum", T: proto3.getEnumType(SortOrder) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JsonIndexSpec {
    return new JsonIndexSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JsonIndexSpec {
    return new JsonIndexSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JsonIndexSpec {
    return new JsonIndexSpec().fromJsonString(jsonString, options);
  }

  static equals(a: JsonIndexSpec | PlainMessage<JsonIndexSpec> | undefined, b: JsonIndexSpec | PlainMessage<JsonIndexSpec> | undefined): boolean {
    return proto3.util.equals(JsonIndexSpec, a, b);
  }
}

/**
 * How records should be filtered to determine which ones to include in an index.
 *
 * @generated from message co.topl.genus.services.IndexFilter
 */
export class IndexFilter extends Message<IndexFilter> {
  /**
   * @generated from oneof co.topl.genus.services.IndexFilter.filter
   */
  filter: {
    /**
     * @generated from field: string regexIndexFilter = 1;
     */
    value: string;
    case: "regexIndexFilter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IndexFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.IndexFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "regexIndexFilter", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexFilter {
    return new IndexFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexFilter {
    return new IndexFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexFilter {
    return new IndexFilter().fromJsonString(jsonString, options);
  }

  static equals(a: IndexFilter | PlainMessage<IndexFilter> | undefined, b: IndexFilter | PlainMessage<IndexFilter> | undefined): boolean {
    return proto3.util.equals(IndexFilter, a, b);
  }
}

/**
 * @generated from message co.topl.genus.services.TransactionReceipt
 */
export class TransactionReceipt extends Message<TransactionReceipt> {
  /**
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  /**
   * @generated from field: co.topl.genus.services.ConfidenceFactor confidenceFactor = 2;
   */
  confidenceFactor?: ConfidenceFactor;

  /**
   * @generated from field: co.topl.consensus.models.BlockId blockId = 3;
   */
  blockId?: BlockId;

  /**
   * @generated from field: co.topl.genus.services.ChainDistance depth = 4;
   */
  depth?: ChainDistance;

  constructor(data?: PartialMessage<TransactionReceipt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.TransactionReceipt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "message", T: IoTransaction },
    { no: 2, name: "confidenceFactor", kind: "message", T: ConfidenceFactor },
    { no: 3, name: "blockId", kind: "message", T: BlockId },
    { no: 4, name: "depth", kind: "message", T: ChainDistance },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined, b: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined): boolean {
    return proto3.util.equals(TransactionReceipt, a, b);
  }
}

/**
 * Data structure that encapsulates relation between a possible block data and its height.
 *
 * @generated from message co.topl.genus.services.HeightData
 */
export class HeightData extends Message<HeightData> {
  /**
   * @generated from field: int64 height = 1;
   */
  height = protoInt64.zero;

  /**
   * @generated from field: co.topl.genus.services.BlockData blockData = 2;
   */
  blockData?: BlockData;

  constructor(data?: PartialMessage<HeightData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.HeightData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "blockData", kind: "message", T: BlockData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeightData {
    return new HeightData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeightData {
    return new HeightData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeightData {
    return new HeightData().fromJsonString(jsonString, options);
  }

  static equals(a: HeightData | PlainMessage<HeightData> | undefined, b: HeightData | PlainMessage<HeightData> | undefined): boolean {
    return proto3.util.equals(HeightData, a, b);
  }
}

/**
 * Data structure with the most important parts of a Block. Equivalent to a denormalized Full Block.
 *
 * @generated from message co.topl.genus.services.BlockData
 */
export class BlockData extends Message<BlockData> {
  /**
   * @generated from field: co.topl.consensus.models.BlockHeader header = 1;
   */
  header?: BlockHeader;

  /**
   * @generated from field: co.topl.node.models.FullBlockBody body = 4;
   */
  body?: FullBlockBody;

  constructor(data?: PartialMessage<BlockData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "co.topl.genus.services.BlockData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "header", kind: "message", T: BlockHeader },
    { no: 4, name: "body", kind: "message", T: FullBlockBody },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockData {
    return new BlockData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockData {
    return new BlockData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockData {
    return new BlockData().fromJsonString(jsonString, options);
  }

  static equals(a: BlockData | PlainMessage<BlockData> | undefined, b: BlockData | PlainMessage<BlockData> | undefined): boolean {
    return proto3.util.equals(BlockData, a, b);
  }
}

