// @generated by protoc-gen-es v1.8.0
// @generated from file genus/genus_models.proto (package co.topl.genus.services, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { UnspentTransactionOutput } from "../brambl/models/transaction/unspent_transaction_output_pb.js";
import type { LockAddress, TransactionInputAddress, TransactionOutputAddress } from "../brambl/models/address_pb.js";
import type { SpentTransactionOutput } from "../brambl/models/transaction/spent_transaction_output_pb.js";
import type { IoTransaction } from "../brambl/models/transaction/io_transaction_pb.js";
import type { BlockId } from "../consensus/models/block_id_pb.js";
import type { BlockHeader } from "../consensus/models/block_header_pb.js";
import type { FullBlockBody } from "../node/models/block_pb.js";

/**
 * Used to identify the status of a Txo.
 *
 * @generated from enum co.topl.genus.services.TxoState
 */
export declare enum TxoState {
  /**
   * The TxO is spent
   *
   * @generated from enum value: SPENT = 0;
   */
  SPENT = 0,

  /**
   * The TxO is not spent
   *
   * @generated from enum value: UNSPENT = 1;
   */
  UNSPENT = 1,

  /**
   * A transaction is pending that may spend the TXO. This state should only appear in bifrost clients.
   *
   * @generated from enum value: PENDING = 2;
   */
  PENDING = 2,
}

/**
 * Specify the order of data for indexes.
 *
 * @generated from enum co.topl.genus.services.SortOrder
 */
export declare enum SortOrder {
  /**
   * @generated from enum value: ASCENDING = 0;
   */
  ASCENDING = 0,

  /**
   * @generated from enum value: DESCENDING = 1;
   */
  DESCENDING = 1,

  /**
   * @generated from enum value: UNSORTED = 2;
   */
  UNSORTED = 2,
}

/**
 * Types of assets that can be identified by an AssetLabel
 *
 * @generated from enum co.topl.genus.services.LabelType
 */
export declare enum LabelType {
  /**
   * @generated from enum value: EMPTY = 0;
   */
  EMPTY = 0,

  /**
   * @generated from enum value: LVL = 1;
   */
  LVL = 1,

  /**
   * @generated from enum value: TOPL = 2;
   */
  TOPL = 2,

  /**
   * @generated from enum value: V1 = 3;
   */
  V1 = 3,

  /**
   * @generated from enum value: TAM2 = 4;
   */
  TAM2 = 4,
}

/**
 * A Txo and its status
 *
 * @generated from message co.topl.genus.services.Txo
 */
export declare class Txo extends Message<Txo> {
  /**
   * @generated from field: co.topl.brambl.models.transaction.UnspentTransactionOutput transactionOutput = 1;
   */
  transactionOutput?: UnspentTransactionOutput;

  /**
   * @generated from field: co.topl.genus.services.TxoState state = 2;
   */
  state: TxoState;

  /**
   * @generated from field: co.topl.brambl.models.TransactionOutputAddress outputAddress = 3;
   */
  outputAddress?: TransactionOutputAddress;

  /**
   * When 'state' is "SPENT", this field points to the transaction (input) that spent it.
   * Otherwise, this field is empty.
   *
   * @generated from field: co.topl.genus.services.Txo.Spender spender = 4;
   */
  spender?: Txo_Spender;

  constructor(data?: PartialMessage<Txo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.Txo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Txo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Txo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Txo;

  static equals(a: Txo | PlainMessage<Txo> | undefined, b: Txo | PlainMessage<Txo> | undefined): boolean;
}

/**
 * @generated from message co.topl.genus.services.Txo.Spender
 */
export declare class Txo_Spender extends Message<Txo_Spender> {
  /**
   * @generated from field: co.topl.brambl.models.TransactionInputAddress inputAddress = 1;
   */
  inputAddress?: TransactionInputAddress;

  /**
   * @generated from field: co.topl.brambl.models.transaction.SpentTransactionOutput input = 2;
   */
  input?: SpentTransactionOutput;

  constructor(data?: PartialMessage<Txo_Spender>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.Txo.Spender";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Txo_Spender;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Txo_Spender;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Txo_Spender;

  static equals(a: Txo_Spender | PlainMessage<Txo_Spender> | undefined, b: Txo_Spender | PlainMessage<Txo_Spender> | undefined): boolean;
}

/**
 * 1 - the probability that something will be subject to a reorg.
 * Defaults to 0.9999999
 *
 * @generated from message co.topl.genus.services.ConfidenceFactor
 */
export declare class ConfidenceFactor extends Message<ConfidenceFactor> {
  /**
   * @generated from field: double value = 1;
   */
  value: number;

  constructor(data?: PartialMessage<ConfidenceFactor>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.ConfidenceFactor";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfidenceFactor;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfidenceFactor;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfidenceFactor;

  static equals(a: ConfidenceFactor | PlainMessage<ConfidenceFactor> | undefined, b: ConfidenceFactor | PlainMessage<ConfidenceFactor> | undefined): boolean;
}

/**
 * The distance between blocks
 *
 * @generated from message co.topl.genus.services.ChainDistance
 */
export declare class ChainDistance extends Message<ChainDistance> {
  /**
   * @generated from field: int64 value = 1;
   */
  value: bigint;

  constructor(data?: PartialMessage<ChainDistance>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.ChainDistance";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainDistance;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainDistance;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainDistance;

  static equals(a: ChainDistance | PlainMessage<ChainDistance> | undefined, b: ChainDistance | PlainMessage<ChainDistance> | undefined): boolean;
}

/**
 * An identifier for a TAM2 asset type
 *
 * @generated from message co.topl.genus.services.AssetLabel
 */
export declare class AssetLabel extends Message<AssetLabel> {
  /**
   * @generated from field: co.topl.genus.services.LabelType labelType = 1;
   */
  labelType: LabelType;

  /**
   * @generated from oneof co.topl.genus.services.AssetLabel.label
   */
  label: {
    /**
     * Since this is a one-of we need to have a field to use for the label types such as LVL that don't need them.
     *
     * @generated from field: co.topl.genus.services.AssetLabel.Empty empty = 2;
     */
    value: AssetLabel_Empty;
    case: "empty";
  } | {
    /**
     * @generated from field: co.topl.genus.services.AssetLabel.V1Label v1Label = 3;
     */
    value: AssetLabel_V1Label;
    case: "v1Label";
  } | {
    /**
     * @generated from field: co.topl.genus.services.AssetLabel.Tam2Label tam2Label = 4;
     */
    value: AssetLabel_Tam2Label;
    case: "tam2Label";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<AssetLabel>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel;

  static equals(a: AssetLabel | PlainMessage<AssetLabel> | undefined, b: AssetLabel | PlainMessage<AssetLabel> | undefined): boolean;
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.Empty
 */
export declare class AssetLabel_Empty extends Message<AssetLabel_Empty> {
  constructor(data?: PartialMessage<AssetLabel_Empty>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.Empty";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_Empty;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_Empty;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_Empty;

  static equals(a: AssetLabel_Empty | PlainMessage<AssetLabel_Empty> | undefined, b: AssetLabel_Empty | PlainMessage<AssetLabel_Empty> | undefined): boolean;
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.V1Label
 */
export declare class AssetLabel_V1Label extends Message<AssetLabel_V1Label> {
  /**
   * @generated from field: uint32 version = 1;
   */
  version: number;

  /**
   * @generated from field: co.topl.brambl.models.LockAddress mintingAddress = 2;
   */
  mintingAddress?: LockAddress;

  constructor(data?: PartialMessage<AssetLabel_V1Label>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.V1Label";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_V1Label;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_V1Label;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_V1Label;

  static equals(a: AssetLabel_V1Label | PlainMessage<AssetLabel_V1Label> | undefined, b: AssetLabel_V1Label | PlainMessage<AssetLabel_V1Label> | undefined): boolean;
}

/**
 * @generated from message co.topl.genus.services.AssetLabel.Tam2Label
 */
export declare class AssetLabel_Tam2Label extends Message<AssetLabel_Tam2Label> {
  /**
   * @generated from field: fixed64 groupHashMostSignificant = 1;
   */
  groupHashMostSignificant: bigint;

  /**
   * @generated from field: fixed64 groupHashMoreSignificant = 2;
   */
  groupHashMoreSignificant: bigint;

  /**
   * @generated from field: fixed64 groupHashLessSignificant = 3;
   */
  groupHashLessSignificant: bigint;

  /**
   * @generated from field: fixed64 groupHashLeastSignificant = 4;
   */
  groupHashLeastSignificant: bigint;

  /**
   * @generated from field: fixed64 seriesHashMostSignificant = 5;
   */
  seriesHashMostSignificant: bigint;

  /**
   * @generated from field: fixed64 seriesHashMoreSignificant = 6;
   */
  seriesHashMoreSignificant: bigint;

  /**
   * @generated from field: fixed64 seriesHashLessSignificant = 7;
   */
  seriesHashLessSignificant: bigint;

  /**
   * @generated from field: fixed64 seriesHashLeastSignificant = 8;
   */
  seriesHashLeastSignificant: bigint;

  constructor(data?: PartialMessage<AssetLabel_Tam2Label>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.AssetLabel.Tam2Label";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssetLabel_Tam2Label;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssetLabel_Tam2Label;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssetLabel_Tam2Label;

  static equals(a: AssetLabel_Tam2Label | PlainMessage<AssetLabel_Tam2Label> | undefined, b: AssetLabel_Tam2Label | PlainMessage<AssetLabel_Tam2Label> | undefined): boolean;
}

/**
 * A request to create an index of transaction based on their on-chain metadata
 *
 * @generated from message co.topl.genus.services.IndexSpec
 */
export declare class IndexSpec extends Message<IndexSpec> {
  /**
   * The name of the index
   *
   * @generated from field: string indexName = 1;
   */
  indexName: string;

  /**
   * A description of the fields to be indexed
   *
   * @generated from field: co.topl.genus.services.IndexFieldSpec indexFieldSpec = 2;
   */
  indexFieldSpec?: IndexFieldSpec;

  /**
   * Filter to determine which transactions are included in the index. Only records that match the filter will be included in the index.
   *
   * @generated from field: co.topl.genus.services.IndexFilter indexFilter = 3;
   */
  indexFilter?: IndexFilter;

  constructor(data?: PartialMessage<IndexSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.IndexSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexSpec;

  static equals(a: IndexSpec | PlainMessage<IndexSpec> | undefined, b: IndexSpec | PlainMessage<IndexSpec> | undefined): boolean;
}

/**
 * A specification to identify the field(s) in data to be indexed
 *
 * @generated from message co.topl.genus.services.IndexFieldSpec
 */
export declare class IndexFieldSpec extends Message<IndexFieldSpec> {
  /**
   * @generated from oneof co.topl.genus.services.IndexFieldSpec.spec
   */
  spec: {
    /**
     * @generated from field: co.topl.genus.services.JsonIndexSpecs jsonSpecs = 1;
     */
    value: JsonIndexSpecs;
    case: "jsonSpecs";
  } | {
    /**
     * TODO ways to specify indexes for other types of data
     *
     * @generated from field: co.topl.genus.services.CsvIndexSpecs csvSpecs = 2;
     */
    value: CsvIndexSpecs;
    case: "csvSpecs";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<IndexFieldSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.IndexFieldSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexFieldSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexFieldSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexFieldSpec;

  static equals(a: IndexFieldSpec | PlainMessage<IndexFieldSpec> | undefined, b: IndexFieldSpec | PlainMessage<IndexFieldSpec> | undefined): boolean;
}

/**
 * a sequence of csv field references to identify the values in data to be indexed
 *
 * @generated from message co.topl.genus.services.CsvIndexSpecs
 */
export declare class CsvIndexSpecs extends Message<CsvIndexSpecs> {
  /**
   * @generated from field: repeated co.topl.genus.services.CsvIndexSpec specs = 1;
   */
  specs: CsvIndexSpec[];

  /**
   * The character code that is used to separate fields.
   *
   * @generated from field: uint32 separatorChar = 2;
   */
  separatorChar: number;

  /**
   * If this is present, the specified character appears at the beginning and end of each field.
   *
   * @generated from field: google.protobuf.UInt32Value quoteChar = 3;
   */
  quoteChar?: number;

  constructor(data?: PartialMessage<CsvIndexSpecs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.CsvIndexSpecs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CsvIndexSpecs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CsvIndexSpecs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CsvIndexSpecs;

  static equals(a: CsvIndexSpecs | PlainMessage<CsvIndexSpecs> | undefined, b: CsvIndexSpecs | PlainMessage<CsvIndexSpecs> | undefined): boolean;
}

/**
 * a sequence of csv field references to identify the values in data to be indexed
 *
 * @generated from message co.topl.genus.services.CsvIndexSpec
 */
export declare class CsvIndexSpec extends Message<CsvIndexSpec> {
  /**
   * Origin 1 field index
   *
   * @generated from field: uint32 fieldIndex = 1;
   */
  fieldIndex: number;

  /**
   * @generated from field: co.topl.genus.services.SortOrder sortOrder = 2;
   */
  sortOrder: SortOrder;

  /**
   * If this is true, the field is sorted numerically; otherwise lexically.
   *
   * @generated from field: bool isNumeric = 3;
   */
  isNumeric: boolean;

  constructor(data?: PartialMessage<CsvIndexSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.CsvIndexSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CsvIndexSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CsvIndexSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CsvIndexSpec;

  static equals(a: CsvIndexSpec | PlainMessage<CsvIndexSpec> | undefined, b: CsvIndexSpec | PlainMessage<CsvIndexSpec> | undefined): boolean;
}

/**
 * A sequence of JSONPath strings to identify the values in data to be indexed (https://datatracker.ietf.org/doc/id/draft-goessner-dispatch-jsonpath-00.html)
 *
 * @generated from message co.topl.genus.services.JsonIndexSpecs
 */
export declare class JsonIndexSpecs extends Message<JsonIndexSpecs> {
  /**
   * @generated from field: repeated co.topl.genus.services.JsonIndexSpec specs = 1;
   */
  specs: JsonIndexSpec[];

  constructor(data?: PartialMessage<JsonIndexSpecs>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.JsonIndexSpecs";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JsonIndexSpecs;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JsonIndexSpecs;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JsonIndexSpecs;

  static equals(a: JsonIndexSpecs | PlainMessage<JsonIndexSpecs> | undefined, b: JsonIndexSpecs | PlainMessage<JsonIndexSpecs> | undefined): boolean;
}

/**
 * A JSONPath string to identify a value in data to be indexed (https://datatracker.ietf.org/doc/id/draft-goessner-dispatch-jsonpath-00.html)
 *
 * @generated from message co.topl.genus.services.JsonIndexSpec
 */
export declare class JsonIndexSpec extends Message<JsonIndexSpec> {
  /**
   * @generated from field: string jsonPath = 1;
   */
  jsonPath: string;

  /**
   * @generated from field: co.topl.genus.services.SortOrder sortOrder = 2;
   */
  sortOrder: SortOrder;

  constructor(data?: PartialMessage<JsonIndexSpec>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.JsonIndexSpec";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JsonIndexSpec;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JsonIndexSpec;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JsonIndexSpec;

  static equals(a: JsonIndexSpec | PlainMessage<JsonIndexSpec> | undefined, b: JsonIndexSpec | PlainMessage<JsonIndexSpec> | undefined): boolean;
}

/**
 * How records should be filtered to determine which ones to include in an index.
 *
 * @generated from message co.topl.genus.services.IndexFilter
 */
export declare class IndexFilter extends Message<IndexFilter> {
  /**
   * @generated from oneof co.topl.genus.services.IndexFilter.filter
   */
  filter: {
    /**
     * @generated from field: string regexIndexFilter = 1;
     */
    value: string;
    case: "regexIndexFilter";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<IndexFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.IndexFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IndexFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IndexFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IndexFilter;

  static equals(a: IndexFilter | PlainMessage<IndexFilter> | undefined, b: IndexFilter | PlainMessage<IndexFilter> | undefined): boolean;
}

/**
 * @generated from message co.topl.genus.services.TransactionReceipt
 */
export declare class TransactionReceipt extends Message<TransactionReceipt> {
  /**
   * @generated from field: co.topl.brambl.models.transaction.IoTransaction transaction = 1;
   */
  transaction?: IoTransaction;

  /**
   * @generated from field: co.topl.genus.services.ConfidenceFactor confidenceFactor = 2;
   */
  confidenceFactor?: ConfidenceFactor;

  /**
   * @generated from field: co.topl.consensus.models.BlockId blockId = 3;
   */
  blockId?: BlockId;

  /**
   * @generated from field: co.topl.genus.services.ChainDistance depth = 4;
   */
  depth?: ChainDistance;

  constructor(data?: PartialMessage<TransactionReceipt>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.TransactionReceipt";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionReceipt;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionReceipt;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionReceipt;

  static equals(a: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined, b: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined): boolean;
}

/**
 * Data structure that encapsulates relation between a possible block data and its height.
 *
 * @generated from message co.topl.genus.services.HeightData
 */
export declare class HeightData extends Message<HeightData> {
  /**
   * @generated from field: int64 height = 1;
   */
  height: bigint;

  /**
   * @generated from field: co.topl.genus.services.BlockData blockData = 2;
   */
  blockData?: BlockData;

  constructor(data?: PartialMessage<HeightData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.HeightData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeightData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeightData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeightData;

  static equals(a: HeightData | PlainMessage<HeightData> | undefined, b: HeightData | PlainMessage<HeightData> | undefined): boolean;
}

/**
 * Data structure with the most important parts of a Block. Equivalent to a denormalized Full Block.
 *
 * @generated from message co.topl.genus.services.BlockData
 */
export declare class BlockData extends Message<BlockData> {
  /**
   * @generated from field: co.topl.consensus.models.BlockHeader header = 1;
   */
  header?: BlockHeader;

  /**
   * @generated from field: co.topl.node.models.FullBlockBody body = 4;
   */
  body?: FullBlockBody;

  constructor(data?: PartialMessage<BlockData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "co.topl.genus.services.BlockData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockData;

  static equals(a: BlockData | PlainMessage<BlockData> | undefined, b: BlockData | PlainMessage<BlockData> | undefined): boolean;
}

