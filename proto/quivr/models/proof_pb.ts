// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file quivr/models/proof.proto (package quivr.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Preimage, TxBind, Witness } from "./shared_pb.js";

/**
 * Proofs that are used to satisfy propositions
 *
 * @generated from message quivr.models.Proof
 */
export class Proof extends Message<Proof> {
  /**
   * @generated from oneof quivr.models.Proof.value
   */
  value: {
    /**
     * @generated from field: quivr.models.Proof.Locked locked = 1;
     */
    value: Proof_Locked;
    case: "locked";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Digest digest = 2;
     */
    value: Proof_Digest;
    case: "digest";
  } | {
    /**
     * @generated from field: quivr.models.Proof.DigitalSignature digitalSignature = 3;
     */
    value: Proof_DigitalSignature;
    case: "digitalSignature";
  } | {
    /**
     * @generated from field: quivr.models.Proof.HeightRange heightRange = 4;
     */
    value: Proof_HeightRange;
    case: "heightRange";
  } | {
    /**
     * @generated from field: quivr.models.Proof.TickRange tickRange = 5;
     */
    value: Proof_TickRange;
    case: "tickRange";
  } | {
    /**
     * @generated from field: quivr.models.Proof.ExactMatch exactMatch = 6;
     */
    value: Proof_ExactMatch;
    case: "exactMatch";
  } | {
    /**
     * @generated from field: quivr.models.Proof.LessThan lessThan = 7;
     */
    value: Proof_LessThan;
    case: "lessThan";
  } | {
    /**
     * @generated from field: quivr.models.Proof.GreaterThan greaterThan = 8;
     */
    value: Proof_GreaterThan;
    case: "greaterThan";
  } | {
    /**
     * @generated from field: quivr.models.Proof.EqualTo equalTo = 9;
     */
    value: Proof_EqualTo;
    case: "equalTo";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Threshold threshold = 10;
     */
    value: Proof_Threshold;
    case: "threshold";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Not not = 11;
     */
    value: Proof_Not;
    case: "not";
  } | {
    /**
     * @generated from field: quivr.models.Proof.And and = 12;
     */
    value: Proof_And;
    case: "and";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Or or = 13;
     */
    value: Proof_Or;
    case: "or";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Proof>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locked", kind: "message", T: Proof_Locked, oneof: "value" },
    { no: 2, name: "digest", kind: "message", T: Proof_Digest, oneof: "value" },
    { no: 3, name: "digitalSignature", kind: "message", T: Proof_DigitalSignature, oneof: "value" },
    { no: 4, name: "heightRange", kind: "message", T: Proof_HeightRange, oneof: "value" },
    { no: 5, name: "tickRange", kind: "message", T: Proof_TickRange, oneof: "value" },
    { no: 6, name: "exactMatch", kind: "message", T: Proof_ExactMatch, oneof: "value" },
    { no: 7, name: "lessThan", kind: "message", T: Proof_LessThan, oneof: "value" },
    { no: 8, name: "greaterThan", kind: "message", T: Proof_GreaterThan, oneof: "value" },
    { no: 9, name: "equalTo", kind: "message", T: Proof_EqualTo, oneof: "value" },
    { no: 10, name: "threshold", kind: "message", T: Proof_Threshold, oneof: "value" },
    { no: 11, name: "not", kind: "message", T: Proof_Not, oneof: "value" },
    { no: 12, name: "and", kind: "message", T: Proof_And, oneof: "value" },
    { no: 13, name: "or", kind: "message", T: Proof_Or, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof {
    return new Proof().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof {
    return new Proof().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof {
    return new Proof().fromJsonString(jsonString, options);
  }

  static equals(a: Proof | PlainMessage<Proof> | undefined, b: Proof | PlainMessage<Proof> | undefined): boolean {
    return proto3.util.equals(Proof, a, b);
  }
}

/**
 * token = "locked"
 *
 * txBind = [0]
 *
 * @generated from message quivr.models.Proof.Locked
 */
export class Proof_Locked extends Message<Proof_Locked> {
  constructor(data?: PartialMessage<Proof_Locked>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.Locked";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Locked {
    return new Proof_Locked().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Locked {
    return new Proof_Locked().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Locked {
    return new Proof_Locked().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_Locked | PlainMessage<Proof_Locked> | undefined, b: Proof_Locked | PlainMessage<Proof_Locked> | undefined): boolean {
    return proto3.util.equals(Proof_Locked, a, b);
  }
}

/**
 * token = "digest"
 *
 * @generated from message quivr.models.Proof.Digest
 */
export class Proof_Digest extends Message<Proof_Digest> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Preimage preimage = 2;
   */
  preimage?: Preimage;

  constructor(data?: PartialMessage<Proof_Digest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.Digest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "preimage", kind: "message", T: Preimage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Digest {
    return new Proof_Digest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Digest {
    return new Proof_Digest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Digest {
    return new Proof_Digest().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_Digest | PlainMessage<Proof_Digest> | undefined, b: Proof_Digest | PlainMessage<Proof_Digest> | undefined): boolean {
    return proto3.util.equals(Proof_Digest, a, b);
  }
}

/**
 * token = "digital_signature"
 *
 * @generated from message quivr.models.Proof.DigitalSignature
 */
export class Proof_DigitalSignature extends Message<Proof_DigitalSignature> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Witness witness = 2;
   */
  witness?: Witness;

  constructor(data?: PartialMessage<Proof_DigitalSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.DigitalSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "witness", kind: "message", T: Witness },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_DigitalSignature {
    return new Proof_DigitalSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_DigitalSignature {
    return new Proof_DigitalSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_DigitalSignature {
    return new Proof_DigitalSignature().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_DigitalSignature | PlainMessage<Proof_DigitalSignature> | undefined, b: Proof_DigitalSignature | PlainMessage<Proof_DigitalSignature> | undefined): boolean {
    return proto3.util.equals(Proof_DigitalSignature, a, b);
  }
}

/**
 * token = "height_range"
 *
 * @generated from message quivr.models.Proof.HeightRange
 */
export class Proof_HeightRange extends Message<Proof_HeightRange> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_HeightRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.HeightRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_HeightRange {
    return new Proof_HeightRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_HeightRange {
    return new Proof_HeightRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_HeightRange {
    return new Proof_HeightRange().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_HeightRange | PlainMessage<Proof_HeightRange> | undefined, b: Proof_HeightRange | PlainMessage<Proof_HeightRange> | undefined): boolean {
    return proto3.util.equals(Proof_HeightRange, a, b);
  }
}

/**
 * token = "tick_range"
 *
 * @generated from message quivr.models.Proof.TickRange
 */
export class Proof_TickRange extends Message<Proof_TickRange> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_TickRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.TickRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_TickRange {
    return new Proof_TickRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_TickRange {
    return new Proof_TickRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_TickRange {
    return new Proof_TickRange().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_TickRange | PlainMessage<Proof_TickRange> | undefined, b: Proof_TickRange | PlainMessage<Proof_TickRange> | undefined): boolean {
    return proto3.util.equals(Proof_TickRange, a, b);
  }
}

/**
 * token = "exact_match"
 *
 * @generated from message quivr.models.Proof.ExactMatch
 */
export class Proof_ExactMatch extends Message<Proof_ExactMatch> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_ExactMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.ExactMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_ExactMatch {
    return new Proof_ExactMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_ExactMatch {
    return new Proof_ExactMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_ExactMatch {
    return new Proof_ExactMatch().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_ExactMatch | PlainMessage<Proof_ExactMatch> | undefined, b: Proof_ExactMatch | PlainMessage<Proof_ExactMatch> | undefined): boolean {
    return proto3.util.equals(Proof_ExactMatch, a, b);
  }
}

/**
 * token = "less_than"
 *
 * @generated from message quivr.models.Proof.LessThan
 */
export class Proof_LessThan extends Message<Proof_LessThan> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_LessThan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.LessThan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_LessThan {
    return new Proof_LessThan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_LessThan {
    return new Proof_LessThan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_LessThan {
    return new Proof_LessThan().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_LessThan | PlainMessage<Proof_LessThan> | undefined, b: Proof_LessThan | PlainMessage<Proof_LessThan> | undefined): boolean {
    return proto3.util.equals(Proof_LessThan, a, b);
  }
}

/**
 * token = "greater_than"
 *
 * @generated from message quivr.models.Proof.GreaterThan
 */
export class Proof_GreaterThan extends Message<Proof_GreaterThan> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_GreaterThan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.GreaterThan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_GreaterThan {
    return new Proof_GreaterThan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_GreaterThan {
    return new Proof_GreaterThan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_GreaterThan {
    return new Proof_GreaterThan().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_GreaterThan | PlainMessage<Proof_GreaterThan> | undefined, b: Proof_GreaterThan | PlainMessage<Proof_GreaterThan> | undefined): boolean {
    return proto3.util.equals(Proof_GreaterThan, a, b);
  }
}

/**
 * token = "equal_to"
 *
 * @generated from message quivr.models.Proof.EqualTo
 */
export class Proof_EqualTo extends Message<Proof_EqualTo> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_EqualTo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.EqualTo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_EqualTo {
    return new Proof_EqualTo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_EqualTo {
    return new Proof_EqualTo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_EqualTo {
    return new Proof_EqualTo().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_EqualTo | PlainMessage<Proof_EqualTo> | undefined, b: Proof_EqualTo | PlainMessage<Proof_EqualTo> | undefined): boolean {
    return proto3.util.equals(Proof_EqualTo, a, b);
  }
}

/**
 * token = "threshold"
 *
 * @generated from message quivr.models.Proof.Threshold
 */
export class Proof_Threshold extends Message<Proof_Threshold> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * set of optional values
   *
   * @generated from field: repeated quivr.models.Proof responses = 2;
   */
  responses: Proof[] = [];

  constructor(data?: PartialMessage<Proof_Threshold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.Threshold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "responses", kind: "message", T: Proof, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Threshold {
    return new Proof_Threshold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Threshold {
    return new Proof_Threshold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Threshold {
    return new Proof_Threshold().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_Threshold | PlainMessage<Proof_Threshold> | undefined, b: Proof_Threshold | PlainMessage<Proof_Threshold> | undefined): boolean {
    return proto3.util.equals(Proof_Threshold, a, b);
  }
}

/**
 * token = "not"
 *
 * @generated from message quivr.models.Proof.Not
 */
export class Proof_Not extends Message<Proof_Not> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof proof = 2;
   */
  proof?: Proof;

  constructor(data?: PartialMessage<Proof_Not>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.Not";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "proof", kind: "message", T: Proof },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Not {
    return new Proof_Not().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Not {
    return new Proof_Not().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Not {
    return new Proof_Not().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_Not | PlainMessage<Proof_Not> | undefined, b: Proof_Not | PlainMessage<Proof_Not> | undefined): boolean {
    return proto3.util.equals(Proof_Not, a, b);
  }
}

/**
 * token = "and"
 *
 * @generated from message quivr.models.Proof.And
 */
export class Proof_And extends Message<Proof_And> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof left = 2;
   */
  left?: Proof;

  /**
   * @generated from field: quivr.models.Proof right = 3;
   */
  right?: Proof;

  constructor(data?: PartialMessage<Proof_And>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.And";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "left", kind: "message", T: Proof },
    { no: 3, name: "right", kind: "message", T: Proof },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_And {
    return new Proof_And().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_And {
    return new Proof_And().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_And {
    return new Proof_And().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_And | PlainMessage<Proof_And> | undefined, b: Proof_And | PlainMessage<Proof_And> | undefined): boolean {
    return proto3.util.equals(Proof_And, a, b);
  }
}

/**
 * token = "or"
 *
 * @generated from message quivr.models.Proof.Or
 */
export class Proof_Or extends Message<Proof_Or> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof left = 2;
   */
  left?: Proof;

  /**
   * @generated from field: quivr.models.Proof right = 3;
   */
  right?: Proof;

  constructor(data?: PartialMessage<Proof_Or>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proof.Or";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transactionBind", kind: "message", T: TxBind },
    { no: 2, name: "left", kind: "message", T: Proof },
    { no: 3, name: "right", kind: "message", T: Proof },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Or {
    return new Proof_Or().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Or {
    return new Proof_Or().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Or {
    return new Proof_Or().fromJsonString(jsonString, options);
  }

  static equals(a: Proof_Or | PlainMessage<Proof_Or> | undefined, b: Proof_Or | PlainMessage<Proof_Or> | undefined): boolean {
    return proto3.util.equals(Proof_Or, a, b);
  }
}

