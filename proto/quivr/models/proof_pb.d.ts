// @generated by protoc-gen-es v1.8.0
// @generated from file quivr/models/proof.proto (package quivr.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Preimage, TxBind, Witness } from "./shared_pb.js";

/**
 * Proofs that are used to satisfy propositions
 *
 * @generated from message quivr.models.Proof
 */
export declare class Proof extends Message<Proof> {
  /**
   * @generated from oneof quivr.models.Proof.value
   */
  value: {
    /**
     * @generated from field: quivr.models.Proof.Locked locked = 1;
     */
    value: Proof_Locked;
    case: "locked";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Digest digest = 2;
     */
    value: Proof_Digest;
    case: "digest";
  } | {
    /**
     * @generated from field: quivr.models.Proof.DigitalSignature digitalSignature = 3;
     */
    value: Proof_DigitalSignature;
    case: "digitalSignature";
  } | {
    /**
     * @generated from field: quivr.models.Proof.HeightRange heightRange = 4;
     */
    value: Proof_HeightRange;
    case: "heightRange";
  } | {
    /**
     * @generated from field: quivr.models.Proof.TickRange tickRange = 5;
     */
    value: Proof_TickRange;
    case: "tickRange";
  } | {
    /**
     * @generated from field: quivr.models.Proof.ExactMatch exactMatch = 6;
     */
    value: Proof_ExactMatch;
    case: "exactMatch";
  } | {
    /**
     * @generated from field: quivr.models.Proof.LessThan lessThan = 7;
     */
    value: Proof_LessThan;
    case: "lessThan";
  } | {
    /**
     * @generated from field: quivr.models.Proof.GreaterThan greaterThan = 8;
     */
    value: Proof_GreaterThan;
    case: "greaterThan";
  } | {
    /**
     * @generated from field: quivr.models.Proof.EqualTo equalTo = 9;
     */
    value: Proof_EqualTo;
    case: "equalTo";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Threshold threshold = 10;
     */
    value: Proof_Threshold;
    case: "threshold";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Not not = 11;
     */
    value: Proof_Not;
    case: "not";
  } | {
    /**
     * @generated from field: quivr.models.Proof.And and = 12;
     */
    value: Proof_And;
    case: "and";
  } | {
    /**
     * @generated from field: quivr.models.Proof.Or or = 13;
     */
    value: Proof_Or;
    case: "or";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Proof>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof;

  static equals(a: Proof | PlainMessage<Proof> | undefined, b: Proof | PlainMessage<Proof> | undefined): boolean;
}

/**
 * token = "locked"
 *
 * txBind = [0]
 *
 * @generated from message quivr.models.Proof.Locked
 */
export declare class Proof_Locked extends Message<Proof_Locked> {
  constructor(data?: PartialMessage<Proof_Locked>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.Locked";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Locked;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Locked;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Locked;

  static equals(a: Proof_Locked | PlainMessage<Proof_Locked> | undefined, b: Proof_Locked | PlainMessage<Proof_Locked> | undefined): boolean;
}

/**
 * token = "digest"
 *
 * @generated from message quivr.models.Proof.Digest
 */
export declare class Proof_Digest extends Message<Proof_Digest> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Preimage preimage = 2;
   */
  preimage?: Preimage;

  constructor(data?: PartialMessage<Proof_Digest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.Digest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Digest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Digest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Digest;

  static equals(a: Proof_Digest | PlainMessage<Proof_Digest> | undefined, b: Proof_Digest | PlainMessage<Proof_Digest> | undefined): boolean;
}

/**
 * token = "digital_signature"
 *
 * @generated from message quivr.models.Proof.DigitalSignature
 */
export declare class Proof_DigitalSignature extends Message<Proof_DigitalSignature> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Witness witness = 2;
   */
  witness?: Witness;

  constructor(data?: PartialMessage<Proof_DigitalSignature>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.DigitalSignature";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_DigitalSignature;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_DigitalSignature;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_DigitalSignature;

  static equals(a: Proof_DigitalSignature | PlainMessage<Proof_DigitalSignature> | undefined, b: Proof_DigitalSignature | PlainMessage<Proof_DigitalSignature> | undefined): boolean;
}

/**
 * token = "height_range"
 *
 * @generated from message quivr.models.Proof.HeightRange
 */
export declare class Proof_HeightRange extends Message<Proof_HeightRange> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_HeightRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.HeightRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_HeightRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_HeightRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_HeightRange;

  static equals(a: Proof_HeightRange | PlainMessage<Proof_HeightRange> | undefined, b: Proof_HeightRange | PlainMessage<Proof_HeightRange> | undefined): boolean;
}

/**
 * token = "tick_range"
 *
 * @generated from message quivr.models.Proof.TickRange
 */
export declare class Proof_TickRange extends Message<Proof_TickRange> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_TickRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.TickRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_TickRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_TickRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_TickRange;

  static equals(a: Proof_TickRange | PlainMessage<Proof_TickRange> | undefined, b: Proof_TickRange | PlainMessage<Proof_TickRange> | undefined): boolean;
}

/**
 * token = "exact_match"
 *
 * @generated from message quivr.models.Proof.ExactMatch
 */
export declare class Proof_ExactMatch extends Message<Proof_ExactMatch> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_ExactMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.ExactMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_ExactMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_ExactMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_ExactMatch;

  static equals(a: Proof_ExactMatch | PlainMessage<Proof_ExactMatch> | undefined, b: Proof_ExactMatch | PlainMessage<Proof_ExactMatch> | undefined): boolean;
}

/**
 * token = "less_than"
 *
 * @generated from message quivr.models.Proof.LessThan
 */
export declare class Proof_LessThan extends Message<Proof_LessThan> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_LessThan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.LessThan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_LessThan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_LessThan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_LessThan;

  static equals(a: Proof_LessThan | PlainMessage<Proof_LessThan> | undefined, b: Proof_LessThan | PlainMessage<Proof_LessThan> | undefined): boolean;
}

/**
 * token = "greater_than"
 *
 * @generated from message quivr.models.Proof.GreaterThan
 */
export declare class Proof_GreaterThan extends Message<Proof_GreaterThan> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_GreaterThan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.GreaterThan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_GreaterThan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_GreaterThan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_GreaterThan;

  static equals(a: Proof_GreaterThan | PlainMessage<Proof_GreaterThan> | undefined, b: Proof_GreaterThan | PlainMessage<Proof_GreaterThan> | undefined): boolean;
}

/**
 * token = "equal_to"
 *
 * @generated from message quivr.models.Proof.EqualTo
 */
export declare class Proof_EqualTo extends Message<Proof_EqualTo> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  constructor(data?: PartialMessage<Proof_EqualTo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.EqualTo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_EqualTo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_EqualTo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_EqualTo;

  static equals(a: Proof_EqualTo | PlainMessage<Proof_EqualTo> | undefined, b: Proof_EqualTo | PlainMessage<Proof_EqualTo> | undefined): boolean;
}

/**
 * token = "threshold"
 *
 * @generated from message quivr.models.Proof.Threshold
 */
export declare class Proof_Threshold extends Message<Proof_Threshold> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * set of optional values
   *
   * @generated from field: repeated quivr.models.Proof responses = 2;
   */
  responses: Proof[];

  constructor(data?: PartialMessage<Proof_Threshold>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.Threshold";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Threshold;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Threshold;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Threshold;

  static equals(a: Proof_Threshold | PlainMessage<Proof_Threshold> | undefined, b: Proof_Threshold | PlainMessage<Proof_Threshold> | undefined): boolean;
}

/**
 * token = "not"
 *
 * @generated from message quivr.models.Proof.Not
 */
export declare class Proof_Not extends Message<Proof_Not> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof proof = 2;
   */
  proof?: Proof;

  constructor(data?: PartialMessage<Proof_Not>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.Not";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Not;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Not;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Not;

  static equals(a: Proof_Not | PlainMessage<Proof_Not> | undefined, b: Proof_Not | PlainMessage<Proof_Not> | undefined): boolean;
}

/**
 * token = "and"
 *
 * @generated from message quivr.models.Proof.And
 */
export declare class Proof_And extends Message<Proof_And> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof left = 2;
   */
  left?: Proof;

  /**
   * @generated from field: quivr.models.Proof right = 3;
   */
  right?: Proof;

  constructor(data?: PartialMessage<Proof_And>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.And";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_And;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_And;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_And;

  static equals(a: Proof_And | PlainMessage<Proof_And> | undefined, b: Proof_And | PlainMessage<Proof_And> | undefined): boolean;
}

/**
 * token = "or"
 *
 * @generated from message quivr.models.Proof.Or
 */
export declare class Proof_Or extends Message<Proof_Or> {
  /**
   * @generated from field: quivr.models.TxBind transactionBind = 1;
   */
  transactionBind?: TxBind;

  /**
   * @generated from field: quivr.models.Proof left = 2;
   */
  left?: Proof;

  /**
   * @generated from field: quivr.models.Proof right = 3;
   */
  right?: Proof;

  constructor(data?: PartialMessage<Proof_Or>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proof.Or";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proof_Or;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proof_Or;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proof_Or;

  static equals(a: Proof_Or | PlainMessage<Proof_Or> | undefined, b: Proof_Or | PlainMessage<Proof_Or> | undefined): boolean;
}

