// @generated by protoc-gen-es v1.8.0
// @generated from file quivr/models/proposition.proto (package quivr.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Data, Digest, Int128, VerificationKey } from "./shared_pb.js";

/**
 * Condition that must be satisfied to unlock
 *
 * @generated from message quivr.models.Proposition
 */
export declare class Proposition extends Message<Proposition> {
  /**
   * enumeration of different possible propositions
   *
   * @generated from oneof quivr.models.Proposition.value
   */
  value: {
    /**
     * @generated from field: quivr.models.Proposition.Locked locked = 1;
     */
    value: Proposition_Locked;
    case: "locked";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Digest digest = 2;
     */
    value: Proposition_Digest;
    case: "digest";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.DigitalSignature digitalSignature = 3;
     */
    value: Proposition_DigitalSignature;
    case: "digitalSignature";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.HeightRange heightRange = 4;
     */
    value: Proposition_HeightRange;
    case: "heightRange";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.TickRange tickRange = 5;
     */
    value: Proposition_TickRange;
    case: "tickRange";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.ExactMatch exactMatch = 6;
     */
    value: Proposition_ExactMatch;
    case: "exactMatch";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.LessThan lessThan = 7;
     */
    value: Proposition_LessThan;
    case: "lessThan";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.GreaterThan greaterThan = 8;
     */
    value: Proposition_GreaterThan;
    case: "greaterThan";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.EqualTo equalTo = 9;
     */
    value: Proposition_EqualTo;
    case: "equalTo";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Threshold threshold = 10;
     */
    value: Proposition_Threshold;
    case: "threshold";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Not not = 11;
     */
    value: Proposition_Not;
    case: "not";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.And and = 12;
     */
    value: Proposition_And;
    case: "and";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Or or = 13;
     */
    value: Proposition_Or;
    case: "or";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Proposition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition;

  static equals(a: Proposition | PlainMessage<Proposition> | undefined, b: Proposition | PlainMessage<Proposition> | undefined): boolean;
}

/**
 * Indicates that a proposition can never be satisfied
 *
 * @generated from message quivr.models.Proposition.Locked
 */
export declare class Proposition_Locked extends Message<Proposition_Locked> {
  /**
   * Optional metadata
   *
   * @generated from field: quivr.models.Data data = 1;
   */
  data?: Data;

  constructor(data?: PartialMessage<Proposition_Locked>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.Locked";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Locked;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Locked;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Locked;

  static equals(a: Proposition_Locked | PlainMessage<Proposition_Locked> | undefined, b: Proposition_Locked | PlainMessage<Proposition_Locked> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the proof contains the preimage matching the digest
 *
 * @generated from message quivr.models.Proposition.Digest
 */
export declare class Proposition_Digest extends Message<Proposition_Digest> {
  /**
   * @generated from field: string routine = 1;
   */
  routine: string;

  /**
   * @generated from field: quivr.models.Digest digest = 2;
   */
  digest?: Digest;

  constructor(data?: PartialMessage<Proposition_Digest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.Digest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Digest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Digest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Digest;

  static equals(a: Proposition_Digest | PlainMessage<Proposition_Digest> | undefined, b: Proposition_Digest | PlainMessage<Proposition_Digest> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the proof contains the signature
 *
 * @generated from message quivr.models.Proposition.DigitalSignature
 */
export declare class Proposition_DigitalSignature extends Message<Proposition_DigitalSignature> {
  /**
   * @generated from field: string routine = 1;
   */
  routine: string;

  /**
   * @generated from field: quivr.models.VerificationKey verificationKey = 2;
   */
  verificationKey?: VerificationKey;

  constructor(data?: PartialMessage<Proposition_DigitalSignature>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.DigitalSignature";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_DigitalSignature;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_DigitalSignature;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_DigitalSignature;

  static equals(a: Proposition_DigitalSignature | PlainMessage<Proposition_DigitalSignature> | undefined, b: Proposition_DigitalSignature | PlainMessage<Proposition_DigitalSignature> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the specified chain falls within min and max height values
 *
 * @generated from message quivr.models.Proposition.HeightRange
 */
export declare class Proposition_HeightRange extends Message<Proposition_HeightRange> {
  /**
   * @generated from field: string chain = 1;
   */
  chain: string;

  /**
   * @generated from field: uint64 min = 2;
   */
  min: bigint;

  /**
   * @generated from field: uint64 max = 3;
   */
  max: bigint;

  constructor(data?: PartialMessage<Proposition_HeightRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.HeightRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_HeightRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_HeightRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_HeightRange;

  static equals(a: Proposition_HeightRange | PlainMessage<Proposition_HeightRange> | undefined, b: Proposition_HeightRange | PlainMessage<Proposition_HeightRange> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the time value falls within the min and max
 *
 * @generated from message quivr.models.Proposition.TickRange
 */
export declare class Proposition_TickRange extends Message<Proposition_TickRange> {
  /**
   * @generated from field: uint64 min = 1;
   */
  min: bigint;

  /**
   * @generated from field: uint64 max = 2;
   */
  max: bigint;

  constructor(data?: PartialMessage<Proposition_TickRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.TickRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_TickRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_TickRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_TickRange;

  static equals(a: Proposition_TickRange | PlainMessage<Proposition_TickRange> | undefined, b: Proposition_TickRange | PlainMessage<Proposition_TickRange> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the value at a location is an exact match of the compareTo value
 *
 * @generated from message quivr.models.Proposition.ExactMatch
 */
export declare class Proposition_ExactMatch extends Message<Proposition_ExactMatch> {
  /**
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * @generated from field: bytes compareTo = 2;
   */
  compareTo: Uint8Array;

  constructor(data?: PartialMessage<Proposition_ExactMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.ExactMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_ExactMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_ExactMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_ExactMatch;

  static equals(a: Proposition_ExactMatch | PlainMessage<Proposition_ExactMatch> | undefined, b: Proposition_ExactMatch | PlainMessage<Proposition_ExactMatch> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the value at a location is less than the compareTo value
 *
 * @generated from message quivr.models.Proposition.LessThan
 */
export declare class Proposition_LessThan extends Message<Proposition_LessThan> {
  /**
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_LessThan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.LessThan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_LessThan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_LessThan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_LessThan;

  static equals(a: Proposition_LessThan | PlainMessage<Proposition_LessThan> | undefined, b: Proposition_LessThan | PlainMessage<Proposition_LessThan> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the value at a location is greater than the compareTo value
 *
 * @generated from message quivr.models.Proposition.GreaterThan
 */
export declare class Proposition_GreaterThan extends Message<Proposition_GreaterThan> {
  /**
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_GreaterThan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.GreaterThan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_GreaterThan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_GreaterThan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_GreaterThan;

  static equals(a: Proposition_GreaterThan | PlainMessage<Proposition_GreaterThan> | undefined, b: Proposition_GreaterThan | PlainMessage<Proposition_GreaterThan> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the value (int) at a location is equal to the compareTo value
 *
 * @generated from message quivr.models.Proposition.EqualTo
 */
export declare class Proposition_EqualTo extends Message<Proposition_EqualTo> {
  /**
   * @generated from field: string location = 1;
   */
  location: string;

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_EqualTo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.EqualTo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_EqualTo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_EqualTo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_EqualTo;

  static equals(a: Proposition_EqualTo | PlainMessage<Proposition_EqualTo> | undefined, b: Proposition_EqualTo | PlainMessage<Proposition_EqualTo> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if at least the threshold number of propositions are satisfied
 *
 * @generated from message quivr.models.Proposition.Threshold
 */
export declare class Proposition_Threshold extends Message<Proposition_Threshold> {
  /**
   * @generated from field: repeated quivr.models.Proposition challenges = 1;
   */
  challenges: Proposition[];

  /**
   * @generated from field: uint32 threshold = 2;
   */
  threshold: number;

  constructor(data?: PartialMessage<Proposition_Threshold>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.Threshold";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Threshold;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Threshold;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Threshold;

  static equals(a: Proposition_Threshold | PlainMessage<Proposition_Threshold> | undefined, b: Proposition_Threshold | PlainMessage<Proposition_Threshold> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the proposition is contains is not satisfied
 *
 * @generated from message quivr.models.Proposition.Not
 */
export declare class Proposition_Not extends Message<Proposition_Not> {
  /**
   * @generated from field: quivr.models.Proposition proposition = 1;
   */
  proposition?: Proposition;

  constructor(data?: PartialMessage<Proposition_Not>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.Not";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Not;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Not;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Not;

  static equals(a: Proposition_Not | PlainMessage<Proposition_Not> | undefined, b: Proposition_Not | PlainMessage<Proposition_Not> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if the prositions contained are both satisfied
 *
 * @generated from message quivr.models.Proposition.And
 */
export declare class Proposition_And extends Message<Proposition_And> {
  /**
   * @generated from field: quivr.models.Proposition left = 1;
   */
  left?: Proposition;

  /**
   * @generated from field: quivr.models.Proposition right = 2;
   */
  right?: Proposition;

  constructor(data?: PartialMessage<Proposition_And>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.And";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_And;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_And;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_And;

  static equals(a: Proposition_And | PlainMessage<Proposition_And> | undefined, b: Proposition_And | PlainMessage<Proposition_And> | undefined): boolean;
}

/**
 * a proposition that can be satisfied if either of the propositions contained are both satisfied
 *
 * @generated from message quivr.models.Proposition.Or
 */
export declare class Proposition_Or extends Message<Proposition_Or> {
  /**
   * @generated from field: quivr.models.Proposition left = 1;
   */
  left?: Proposition;

  /**
   * @generated from field: quivr.models.Proposition right = 2;
   */
  right?: Proposition;

  constructor(data?: PartialMessage<Proposition_Or>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "quivr.models.Proposition.Or";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Or;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Or;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Or;

  static equals(a: Proposition_Or | PlainMessage<Proposition_Or> | undefined, b: Proposition_Or | PlainMessage<Proposition_Or> | undefined): boolean;
}

