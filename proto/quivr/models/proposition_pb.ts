// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file quivr/models/proposition.proto (package quivr.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Data, Digest, Int128, VerificationKey } from "./shared_pb.js";

/**
 * Condition that must be satisfied to unlock
 *
 * @generated from message quivr.models.Proposition
 */
export class Proposition extends Message<Proposition> {
  /**
   * enumeration of different possible propositions
   *
   * @generated from oneof quivr.models.Proposition.value
   */
  value: {
    /**
     * @generated from field: quivr.models.Proposition.Locked locked = 1;
     */
    value: Proposition_Locked;
    case: "locked";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Digest digest = 2;
     */
    value: Proposition_Digest;
    case: "digest";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.DigitalSignature digitalSignature = 3;
     */
    value: Proposition_DigitalSignature;
    case: "digitalSignature";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.HeightRange heightRange = 4;
     */
    value: Proposition_HeightRange;
    case: "heightRange";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.TickRange tickRange = 5;
     */
    value: Proposition_TickRange;
    case: "tickRange";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.ExactMatch exactMatch = 6;
     */
    value: Proposition_ExactMatch;
    case: "exactMatch";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.LessThan lessThan = 7;
     */
    value: Proposition_LessThan;
    case: "lessThan";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.GreaterThan greaterThan = 8;
     */
    value: Proposition_GreaterThan;
    case: "greaterThan";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.EqualTo equalTo = 9;
     */
    value: Proposition_EqualTo;
    case: "equalTo";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Threshold threshold = 10;
     */
    value: Proposition_Threshold;
    case: "threshold";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Not not = 11;
     */
    value: Proposition_Not;
    case: "not";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.And and = 12;
     */
    value: Proposition_And;
    case: "and";
  } | {
    /**
     * @generated from field: quivr.models.Proposition.Or or = 13;
     */
    value: Proposition_Or;
    case: "or";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Proposition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locked", kind: "message", T: Proposition_Locked, oneof: "value" },
    { no: 2, name: "digest", kind: "message", T: Proposition_Digest, oneof: "value" },
    { no: 3, name: "digitalSignature", kind: "message", T: Proposition_DigitalSignature, oneof: "value" },
    { no: 4, name: "heightRange", kind: "message", T: Proposition_HeightRange, oneof: "value" },
    { no: 5, name: "tickRange", kind: "message", T: Proposition_TickRange, oneof: "value" },
    { no: 6, name: "exactMatch", kind: "message", T: Proposition_ExactMatch, oneof: "value" },
    { no: 7, name: "lessThan", kind: "message", T: Proposition_LessThan, oneof: "value" },
    { no: 8, name: "greaterThan", kind: "message", T: Proposition_GreaterThan, oneof: "value" },
    { no: 9, name: "equalTo", kind: "message", T: Proposition_EqualTo, oneof: "value" },
    { no: 10, name: "threshold", kind: "message", T: Proposition_Threshold, oneof: "value" },
    { no: 11, name: "not", kind: "message", T: Proposition_Not, oneof: "value" },
    { no: 12, name: "and", kind: "message", T: Proposition_And, oneof: "value" },
    { no: 13, name: "or", kind: "message", T: Proposition_Or, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition {
    return new Proposition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition {
    return new Proposition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition {
    return new Proposition().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition | PlainMessage<Proposition> | undefined, b: Proposition | PlainMessage<Proposition> | undefined): boolean {
    return proto3.util.equals(Proposition, a, b);
  }
}

/**
 * Indicates that a proposition can never be satisfied
 *
 * @generated from message quivr.models.Proposition.Locked
 */
export class Proposition_Locked extends Message<Proposition_Locked> {
  /**
   * Optional metadata
   *
   * @generated from field: quivr.models.Data data = 1;
   */
  data?: Data;

  constructor(data?: PartialMessage<Proposition_Locked>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.Locked";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Data },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Locked {
    return new Proposition_Locked().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Locked {
    return new Proposition_Locked().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Locked {
    return new Proposition_Locked().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_Locked | PlainMessage<Proposition_Locked> | undefined, b: Proposition_Locked | PlainMessage<Proposition_Locked> | undefined): boolean {
    return proto3.util.equals(Proposition_Locked, a, b);
  }
}

/**
 * a proposition that can be satisfied if the proof contains the preimage matching the digest
 *
 * @generated from message quivr.models.Proposition.Digest
 */
export class Proposition_Digest extends Message<Proposition_Digest> {
  /**
   * @generated from field: string routine = 1;
   */
  routine = "";

  /**
   * @generated from field: quivr.models.Digest digest = 2;
   */
  digest?: Digest;

  constructor(data?: PartialMessage<Proposition_Digest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.Digest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "routine", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "digest", kind: "message", T: Digest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Digest {
    return new Proposition_Digest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Digest {
    return new Proposition_Digest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Digest {
    return new Proposition_Digest().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_Digest | PlainMessage<Proposition_Digest> | undefined, b: Proposition_Digest | PlainMessage<Proposition_Digest> | undefined): boolean {
    return proto3.util.equals(Proposition_Digest, a, b);
  }
}

/**
 * a proposition that can be satisfied if the proof contains the signature
 *
 * @generated from message quivr.models.Proposition.DigitalSignature
 */
export class Proposition_DigitalSignature extends Message<Proposition_DigitalSignature> {
  /**
   * @generated from field: string routine = 1;
   */
  routine = "";

  /**
   * @generated from field: quivr.models.VerificationKey verificationKey = 2;
   */
  verificationKey?: VerificationKey;

  constructor(data?: PartialMessage<Proposition_DigitalSignature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.DigitalSignature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "routine", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "verificationKey", kind: "message", T: VerificationKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_DigitalSignature {
    return new Proposition_DigitalSignature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_DigitalSignature {
    return new Proposition_DigitalSignature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_DigitalSignature {
    return new Proposition_DigitalSignature().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_DigitalSignature | PlainMessage<Proposition_DigitalSignature> | undefined, b: Proposition_DigitalSignature | PlainMessage<Proposition_DigitalSignature> | undefined): boolean {
    return proto3.util.equals(Proposition_DigitalSignature, a, b);
  }
}

/**
 * a proposition that can be satisfied if the specified chain falls within min and max height values
 *
 * @generated from message quivr.models.Proposition.HeightRange
 */
export class Proposition_HeightRange extends Message<Proposition_HeightRange> {
  /**
   * @generated from field: string chain = 1;
   */
  chain = "";

  /**
   * @generated from field: uint64 min = 2;
   */
  min = protoInt64.zero;

  /**
   * @generated from field: uint64 max = 3;
   */
  max = protoInt64.zero;

  constructor(data?: PartialMessage<Proposition_HeightRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.HeightRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "max", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_HeightRange {
    return new Proposition_HeightRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_HeightRange {
    return new Proposition_HeightRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_HeightRange {
    return new Proposition_HeightRange().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_HeightRange | PlainMessage<Proposition_HeightRange> | undefined, b: Proposition_HeightRange | PlainMessage<Proposition_HeightRange> | undefined): boolean {
    return proto3.util.equals(Proposition_HeightRange, a, b);
  }
}

/**
 * a proposition that can be satisfied if the time value falls within the min and max
 *
 * @generated from message quivr.models.Proposition.TickRange
 */
export class Proposition_TickRange extends Message<Proposition_TickRange> {
  /**
   * @generated from field: uint64 min = 1;
   */
  min = protoInt64.zero;

  /**
   * @generated from field: uint64 max = 2;
   */
  max = protoInt64.zero;

  constructor(data?: PartialMessage<Proposition_TickRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.TickRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_TickRange {
    return new Proposition_TickRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_TickRange {
    return new Proposition_TickRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_TickRange {
    return new Proposition_TickRange().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_TickRange | PlainMessage<Proposition_TickRange> | undefined, b: Proposition_TickRange | PlainMessage<Proposition_TickRange> | undefined): boolean {
    return proto3.util.equals(Proposition_TickRange, a, b);
  }
}

/**
 * a proposition that can be satisfied if the value at a location is an exact match of the compareTo value
 *
 * @generated from message quivr.models.Proposition.ExactMatch
 */
export class Proposition_ExactMatch extends Message<Proposition_ExactMatch> {
  /**
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * @generated from field: bytes compareTo = 2;
   */
  compareTo = new Uint8Array(0);

  constructor(data?: PartialMessage<Proposition_ExactMatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.ExactMatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "compareTo", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_ExactMatch {
    return new Proposition_ExactMatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_ExactMatch {
    return new Proposition_ExactMatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_ExactMatch {
    return new Proposition_ExactMatch().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_ExactMatch | PlainMessage<Proposition_ExactMatch> | undefined, b: Proposition_ExactMatch | PlainMessage<Proposition_ExactMatch> | undefined): boolean {
    return proto3.util.equals(Proposition_ExactMatch, a, b);
  }
}

/**
 * a proposition that can be satisfied if the value at a location is less than the compareTo value
 *
 * @generated from message quivr.models.Proposition.LessThan
 */
export class Proposition_LessThan extends Message<Proposition_LessThan> {
  /**
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_LessThan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.LessThan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "compareTo", kind: "message", T: Int128 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_LessThan {
    return new Proposition_LessThan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_LessThan {
    return new Proposition_LessThan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_LessThan {
    return new Proposition_LessThan().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_LessThan | PlainMessage<Proposition_LessThan> | undefined, b: Proposition_LessThan | PlainMessage<Proposition_LessThan> | undefined): boolean {
    return proto3.util.equals(Proposition_LessThan, a, b);
  }
}

/**
 * a proposition that can be satisfied if the value at a location is greater than the compareTo value
 *
 * @generated from message quivr.models.Proposition.GreaterThan
 */
export class Proposition_GreaterThan extends Message<Proposition_GreaterThan> {
  /**
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_GreaterThan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.GreaterThan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "compareTo", kind: "message", T: Int128 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_GreaterThan {
    return new Proposition_GreaterThan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_GreaterThan {
    return new Proposition_GreaterThan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_GreaterThan {
    return new Proposition_GreaterThan().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_GreaterThan | PlainMessage<Proposition_GreaterThan> | undefined, b: Proposition_GreaterThan | PlainMessage<Proposition_GreaterThan> | undefined): boolean {
    return proto3.util.equals(Proposition_GreaterThan, a, b);
  }
}

/**
 * a proposition that can be satisfied if the value (int) at a location is equal to the compareTo value
 *
 * @generated from message quivr.models.Proposition.EqualTo
 */
export class Proposition_EqualTo extends Message<Proposition_EqualTo> {
  /**
   * @generated from field: string location = 1;
   */
  location = "";

  /**
   * @generated from field: quivr.models.Int128 compareTo = 2;
   */
  compareTo?: Int128;

  constructor(data?: PartialMessage<Proposition_EqualTo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.EqualTo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "compareTo", kind: "message", T: Int128 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_EqualTo {
    return new Proposition_EqualTo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_EqualTo {
    return new Proposition_EqualTo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_EqualTo {
    return new Proposition_EqualTo().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_EqualTo | PlainMessage<Proposition_EqualTo> | undefined, b: Proposition_EqualTo | PlainMessage<Proposition_EqualTo> | undefined): boolean {
    return proto3.util.equals(Proposition_EqualTo, a, b);
  }
}

/**
 * a proposition that can be satisfied if at least the threshold number of propositions are satisfied
 *
 * @generated from message quivr.models.Proposition.Threshold
 */
export class Proposition_Threshold extends Message<Proposition_Threshold> {
  /**
   * @generated from field: repeated quivr.models.Proposition challenges = 1;
   */
  challenges: Proposition[] = [];

  /**
   * @generated from field: uint32 threshold = 2;
   */
  threshold = 0;

  constructor(data?: PartialMessage<Proposition_Threshold>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.Threshold";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "challenges", kind: "message", T: Proposition, repeated: true },
    { no: 2, name: "threshold", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Threshold {
    return new Proposition_Threshold().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Threshold {
    return new Proposition_Threshold().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Threshold {
    return new Proposition_Threshold().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_Threshold | PlainMessage<Proposition_Threshold> | undefined, b: Proposition_Threshold | PlainMessage<Proposition_Threshold> | undefined): boolean {
    return proto3.util.equals(Proposition_Threshold, a, b);
  }
}

/**
 * a proposition that can be satisfied if the proposition is contains is not satisfied
 *
 * @generated from message quivr.models.Proposition.Not
 */
export class Proposition_Not extends Message<Proposition_Not> {
  /**
   * @generated from field: quivr.models.Proposition proposition = 1;
   */
  proposition?: Proposition;

  constructor(data?: PartialMessage<Proposition_Not>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.Not";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposition", kind: "message", T: Proposition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Not {
    return new Proposition_Not().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Not {
    return new Proposition_Not().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Not {
    return new Proposition_Not().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_Not | PlainMessage<Proposition_Not> | undefined, b: Proposition_Not | PlainMessage<Proposition_Not> | undefined): boolean {
    return proto3.util.equals(Proposition_Not, a, b);
  }
}

/**
 * a proposition that can be satisfied if the prositions contained are both satisfied
 *
 * @generated from message quivr.models.Proposition.And
 */
export class Proposition_And extends Message<Proposition_And> {
  /**
   * @generated from field: quivr.models.Proposition left = 1;
   */
  left?: Proposition;

  /**
   * @generated from field: quivr.models.Proposition right = 2;
   */
  right?: Proposition;

  constructor(data?: PartialMessage<Proposition_And>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.And";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: Proposition },
    { no: 2, name: "right", kind: "message", T: Proposition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_And {
    return new Proposition_And().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_And {
    return new Proposition_And().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_And {
    return new Proposition_And().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_And | PlainMessage<Proposition_And> | undefined, b: Proposition_And | PlainMessage<Proposition_And> | undefined): boolean {
    return proto3.util.equals(Proposition_And, a, b);
  }
}

/**
 * a proposition that can be satisfied if either of the propositions contained are both satisfied
 *
 * @generated from message quivr.models.Proposition.Or
 */
export class Proposition_Or extends Message<Proposition_Or> {
  /**
   * @generated from field: quivr.models.Proposition left = 1;
   */
  left?: Proposition;

  /**
   * @generated from field: quivr.models.Proposition right = 2;
   */
  right?: Proposition;

  constructor(data?: PartialMessage<Proposition_Or>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Proposition.Or";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: Proposition },
    { no: 2, name: "right", kind: "message", T: Proposition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Proposition_Or {
    return new Proposition_Or().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Proposition_Or {
    return new Proposition_Or().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Proposition_Or {
    return new Proposition_Or().fromJsonString(jsonString, options);
  }

  static equals(a: Proposition_Or | PlainMessage<Proposition_Or> | undefined, b: Proposition_Or | PlainMessage<Proposition_Or> | undefined): boolean {
    return proto3.util.equals(Proposition_Or, a, b);
  }
}

