// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file quivr/models/shared.proto (package quivr.models, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message as Message$1, proto3 } from "@bufbuild/protobuf";

/**
 * General purpose data
 *
 * @generated from message quivr.models.Data
 */
export class Data extends Message$1<Data> {
  /**
   * Byte representation of data value
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto3.util.equals(Data, a, b);
  }
}

/**
 * Data format used for metadata
 *
 * @generated from message quivr.models.SmallData
 */
export class SmallData extends Message$1<SmallData> {
  /**
   * Maximum length = 64
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SmallData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SmallData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SmallData {
    return new SmallData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SmallData {
    return new SmallData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SmallData {
    return new SmallData().fromJsonString(jsonString, options);
  }

  static equals(a: SmallData | PlainMessage<SmallData> | undefined, b: SmallData | PlainMessage<SmallData> | undefined): boolean {
    return proto3.util.equals(SmallData, a, b);
  }
}

/**
 * Event root
 *
 * @generated from message quivr.models.Root
 */
export class Root extends Message$1<Root> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Root>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Root";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Root {
    return new Root().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Root {
    return new Root().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Root {
    return new Root().fromJsonString(jsonString, options);
  }

  static equals(a: Root | PlainMessage<Root> | undefined, b: Root | PlainMessage<Root> | undefined): boolean {
    return proto3.util.equals(Root, a, b);
  }
}

/**
 * Preimage (input) for a digest operation
 *
 * @generated from message quivr.models.Preimage
 */
export class Preimage extends Message$1<Preimage> {
  /**
   * @generated from field: bytes input = 1;
   */
  input = new Uint8Array(0);

  /**
   * @generated from field: bytes salt = 2;
   */
  salt = new Uint8Array(0);

  constructor(data?: PartialMessage<Preimage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Preimage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "input", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "salt", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Preimage {
    return new Preimage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Preimage {
    return new Preimage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Preimage {
    return new Preimage().fromJsonString(jsonString, options);
  }

  static equals(a: Preimage | PlainMessage<Preimage> | undefined, b: Preimage | PlainMessage<Preimage> | undefined): boolean {
    return proto3.util.equals(Preimage, a, b);
  }
}

/**
 * Information output to Hash
 *
 * @generated from message quivr.models.Digest
 */
export class Digest extends Message$1<Digest> {
  /**
   * strict length = 32
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Digest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Digest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Digest {
    return new Digest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Digest {
    return new Digest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Digest {
    return new Digest().fromJsonString(jsonString, options);
  }

  static equals(a: Digest | PlainMessage<Digest> | undefined, b: Digest | PlainMessage<Digest> | undefined): boolean {
    return proto3.util.equals(Digest, a, b);
  }
}

/**
 * Encapsulates digest and preimage used to verify that preimage results in digest
 *
 * @generated from message quivr.models.DigestVerification
 */
export class DigestVerification extends Message$1<DigestVerification> {
  /**
   * @generated from field: quivr.models.Digest digest = 1;
   */
  digest?: Digest;

  /**
   * @generated from field: quivr.models.Preimage preimage = 2;
   */
  preimage?: Preimage;

  constructor(data?: PartialMessage<DigestVerification>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.DigestVerification";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "digest", kind: "message", T: Digest },
    { no: 2, name: "preimage", kind: "message", T: Preimage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DigestVerification {
    return new DigestVerification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DigestVerification {
    return new DigestVerification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DigestVerification {
    return new DigestVerification().fromJsonString(jsonString, options);
  }

  static equals(a: DigestVerification | PlainMessage<DigestVerification> | undefined, b: DigestVerification | PlainMessage<DigestVerification> | undefined): boolean {
    return proto3.util.equals(DigestVerification, a, b);
  }
}

/**
 * public key in a key pair used for verification
 *
 * @generated from message quivr.models.VerificationKey
 */
export class VerificationKey extends Message$1<VerificationKey> {
  /**
   * @generated from oneof quivr.models.VerificationKey.vk
   */
  vk: {
    /**
     * @generated from field: quivr.models.VerificationKey.Ed25519Vk ed25519 = 1;
     */
    value: VerificationKey_Ed25519Vk;
    case: "ed25519";
  } | {
    /**
     * @generated from field: quivr.models.VerificationKey.ExtendedEd25519Vk extendedEd25519 = 2;
     */
    value: VerificationKey_ExtendedEd25519Vk;
    case: "extendedEd25519";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<VerificationKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.VerificationKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ed25519", kind: "message", T: VerificationKey_Ed25519Vk, oneof: "vk" },
    { no: 2, name: "extendedEd25519", kind: "message", T: VerificationKey_ExtendedEd25519Vk, oneof: "vk" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationKey {
    return new VerificationKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationKey {
    return new VerificationKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationKey {
    return new VerificationKey().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationKey | PlainMessage<VerificationKey> | undefined, b: VerificationKey | PlainMessage<VerificationKey> | undefined): boolean {
    return proto3.util.equals(VerificationKey, a, b);
  }
}

/**
 * @generated from message quivr.models.VerificationKey.Ed25519Vk
 */
export class VerificationKey_Ed25519Vk extends Message$1<VerificationKey_Ed25519Vk> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<VerificationKey_Ed25519Vk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.VerificationKey.Ed25519Vk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationKey_Ed25519Vk {
    return new VerificationKey_Ed25519Vk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationKey_Ed25519Vk {
    return new VerificationKey_Ed25519Vk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationKey_Ed25519Vk {
    return new VerificationKey_Ed25519Vk().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationKey_Ed25519Vk | PlainMessage<VerificationKey_Ed25519Vk> | undefined, b: VerificationKey_Ed25519Vk | PlainMessage<VerificationKey_Ed25519Vk> | undefined): boolean {
    return proto3.util.equals(VerificationKey_Ed25519Vk, a, b);
  }
}

/**
 * @generated from message quivr.models.VerificationKey.ExtendedEd25519Vk
 */
export class VerificationKey_ExtendedEd25519Vk extends Message$1<VerificationKey_ExtendedEd25519Vk> {
  /**
   * @generated from field: quivr.models.VerificationKey.Ed25519Vk vk = 1;
   */
  vk?: VerificationKey_Ed25519Vk;

  /**
   * @generated from field: bytes chainCode = 2;
   */
  chainCode = new Uint8Array(0);

  constructor(data?: PartialMessage<VerificationKey_ExtendedEd25519Vk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.VerificationKey.ExtendedEd25519Vk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vk", kind: "message", T: VerificationKey_Ed25519Vk },
    { no: 2, name: "chainCode", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationKey_ExtendedEd25519Vk {
    return new VerificationKey_ExtendedEd25519Vk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationKey_ExtendedEd25519Vk {
    return new VerificationKey_ExtendedEd25519Vk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationKey_ExtendedEd25519Vk {
    return new VerificationKey_ExtendedEd25519Vk().fromJsonString(jsonString, options);
  }

  static equals(a: VerificationKey_ExtendedEd25519Vk | PlainMessage<VerificationKey_ExtendedEd25519Vk> | undefined, b: VerificationKey_ExtendedEd25519Vk | PlainMessage<VerificationKey_ExtendedEd25519Vk> | undefined): boolean {
    return proto3.util.equals(VerificationKey_ExtendedEd25519Vk, a, b);
  }
}

/**
 * Private key used to sign
 *
 * @generated from message quivr.models.SigningKey
 */
export class SigningKey extends Message$1<SigningKey> {
  /**
   * @generated from oneof quivr.models.SigningKey.sk
   */
  sk: {
    /**
     * @generated from field: quivr.models.SigningKey.Ed25519Sk ed25519 = 1;
     */
    value: SigningKey_Ed25519Sk;
    case: "ed25519";
  } | {
    /**
     * @generated from field: quivr.models.SigningKey.ExtendedEd25519Sk extendedEd25519 = 2;
     */
    value: SigningKey_ExtendedEd25519Sk;
    case: "extendedEd25519";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SigningKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SigningKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ed25519", kind: "message", T: SigningKey_Ed25519Sk, oneof: "sk" },
    { no: 2, name: "extendedEd25519", kind: "message", T: SigningKey_ExtendedEd25519Sk, oneof: "sk" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SigningKey {
    return new SigningKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SigningKey {
    return new SigningKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SigningKey {
    return new SigningKey().fromJsonString(jsonString, options);
  }

  static equals(a: SigningKey | PlainMessage<SigningKey> | undefined, b: SigningKey | PlainMessage<SigningKey> | undefined): boolean {
    return proto3.util.equals(SigningKey, a, b);
  }
}

/**
 * @generated from message quivr.models.SigningKey.Ed25519Sk
 */
export class SigningKey_Ed25519Sk extends Message$1<SigningKey_Ed25519Sk> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SigningKey_Ed25519Sk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SigningKey.Ed25519Sk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SigningKey_Ed25519Sk {
    return new SigningKey_Ed25519Sk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SigningKey_Ed25519Sk {
    return new SigningKey_Ed25519Sk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SigningKey_Ed25519Sk {
    return new SigningKey_Ed25519Sk().fromJsonString(jsonString, options);
  }

  static equals(a: SigningKey_Ed25519Sk | PlainMessage<SigningKey_Ed25519Sk> | undefined, b: SigningKey_Ed25519Sk | PlainMessage<SigningKey_Ed25519Sk> | undefined): boolean {
    return proto3.util.equals(SigningKey_Ed25519Sk, a, b);
  }
}

/**
 * @generated from message quivr.models.SigningKey.ExtendedEd25519Sk
 */
export class SigningKey_ExtendedEd25519Sk extends Message$1<SigningKey_ExtendedEd25519Sk> {
  /**
   * @generated from field: bytes leftKey = 1;
   */
  leftKey = new Uint8Array(0);

  /**
   * @generated from field: bytes rightKey = 2;
   */
  rightKey = new Uint8Array(0);

  /**
   * @generated from field: bytes chainCode = 3;
   */
  chainCode = new Uint8Array(0);

  constructor(data?: PartialMessage<SigningKey_ExtendedEd25519Sk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SigningKey.ExtendedEd25519Sk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leftKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "rightKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "chainCode", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SigningKey_ExtendedEd25519Sk {
    return new SigningKey_ExtendedEd25519Sk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SigningKey_ExtendedEd25519Sk {
    return new SigningKey_ExtendedEd25519Sk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SigningKey_ExtendedEd25519Sk {
    return new SigningKey_ExtendedEd25519Sk().fromJsonString(jsonString, options);
  }

  static equals(a: SigningKey_ExtendedEd25519Sk | PlainMessage<SigningKey_ExtendedEd25519Sk> | undefined, b: SigningKey_ExtendedEd25519Sk | PlainMessage<SigningKey_ExtendedEd25519Sk> | undefined): boolean {
    return proto3.util.equals(SigningKey_ExtendedEd25519Sk, a, b);
  }
}

/**
 * Public and private key pairs used to sign and verify
 *
 * @generated from message quivr.models.KeyPair
 */
export class KeyPair extends Message$1<KeyPair> {
  /**
   * @generated from field: quivr.models.VerificationKey vk = 1;
   */
  vk?: VerificationKey;

  /**
   * @generated from field: quivr.models.SigningKey sk = 2;
   */
  sk?: SigningKey;

  constructor(data?: PartialMessage<KeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.KeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vk", kind: "message", T: VerificationKey },
    { no: 2, name: "sk", kind: "message", T: SigningKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyPair {
    return new KeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyPair {
    return new KeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyPair {
    return new KeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: KeyPair | PlainMessage<KeyPair> | undefined, b: KeyPair | PlainMessage<KeyPair> | undefined): boolean {
    return proto3.util.equals(KeyPair, a, b);
  }
}

/**
 * Message to sign
 *
 * @generated from message quivr.models.Message
 */
export class Message extends Message$1<Message> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Message>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Message";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message {
    return new Message().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message {
    return new Message().fromJsonString(jsonString, options);
  }

  static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean {
    return proto3.util.equals(Message, a, b);
  }
}

/**
 * generated signature
 *
 * @generated from message quivr.models.Witness
 */
export class Witness extends Message$1<Witness> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Witness>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Witness";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Witness {
    return new Witness().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Witness {
    return new Witness().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Witness {
    return new Witness().fromJsonString(jsonString, options);
  }

  static equals(a: Witness | PlainMessage<Witness> | undefined, b: Witness | PlainMessage<Witness> | undefined): boolean {
    return proto3.util.equals(Witness, a, b);
  }
}

/**
 * encapsulates data used to verify a signing routine
 *
 * @generated from message quivr.models.SignatureVerification
 */
export class SignatureVerification extends Message$1<SignatureVerification> {
  /**
   * @generated from field: quivr.models.VerificationKey verificationKey = 1;
   */
  verificationKey?: VerificationKey;

  /**
   * @generated from field: quivr.models.Witness signature = 2;
   */
  signature?: Witness;

  /**
   * @generated from field: quivr.models.Message message = 3;
   */
  message?: Message;

  constructor(data?: PartialMessage<SignatureVerification>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SignatureVerification";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "verificationKey", kind: "message", T: VerificationKey },
    { no: 2, name: "signature", kind: "message", T: Witness },
    { no: 3, name: "message", kind: "message", T: Message },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignatureVerification {
    return new SignatureVerification().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignatureVerification {
    return new SignatureVerification().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignatureVerification {
    return new SignatureVerification().fromJsonString(jsonString, options);
  }

  static equals(a: SignatureVerification | PlainMessage<SignatureVerification> | undefined, b: SignatureVerification | PlainMessage<SignatureVerification> | undefined): boolean {
    return proto3.util.equals(SignatureVerification, a, b);
  }
}

/**
 * signable in bytes
 *
 * @generated from message quivr.models.SignableBytes
 */
export class SignableBytes extends Message$1<SignableBytes> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SignableBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.SignableBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SignableBytes {
    return new SignableBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SignableBytes {
    return new SignableBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SignableBytes {
    return new SignableBytes().fromJsonString(jsonString, options);
  }

  static equals(a: SignableBytes | PlainMessage<SignableBytes> | undefined, b: SignableBytes | PlainMessage<SignableBytes> | undefined): boolean {
    return proto3.util.equals(SignableBytes, a, b);
  }
}

/**
 * Transaction bind uses signable bytes to bind a proof
 *
 * @generated from message quivr.models.TxBind
 */
export class TxBind extends Message$1<TxBind> {
  /**
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<TxBind>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.TxBind";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TxBind {
    return new TxBind().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TxBind {
    return new TxBind().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TxBind {
    return new TxBind().fromJsonString(jsonString, options);
  }

  static equals(a: TxBind | PlainMessage<TxBind> | undefined, b: TxBind | PlainMessage<TxBind> | undefined): boolean {
    return proto3.util.equals(TxBind, a, b);
  }
}

/**
 * Represents a 128-bit integer
 *
 * @generated from message quivr.models.Int128
 */
export class Int128 extends Message$1<Int128> {
  /**
   * Java BigInt Representation: two's-complement, big-endian
   *
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Int128>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Int128";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int128 {
    return new Int128().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int128 {
    return new Int128().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int128 {
    return new Int128().fromJsonString(jsonString, options);
  }

  static equals(a: Int128 | PlainMessage<Int128> | undefined, b: Int128 | PlainMessage<Int128> | undefined): boolean {
    return proto3.util.equals(Int128, a, b);
  }
}

/**
 * @generated from message quivr.models.Ratio
 */
export class Ratio extends Message$1<Ratio> {
  /**
   * @generated from field: quivr.models.Int128 numerator = 1;
   */
  numerator?: Int128;

  /**
   * Populate with 1 if not defined
   *
   * @generated from field: quivr.models.Int128 denominator = 2;
   */
  denominator?: Int128;

  constructor(data?: PartialMessage<Ratio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "quivr.models.Ratio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numerator", kind: "message", T: Int128 },
    { no: 2, name: "denominator", kind: "message", T: Int128 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ratio {
    return new Ratio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ratio {
    return new Ratio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ratio {
    return new Ratio().fromJsonString(jsonString, options);
  }

  static equals(a: Ratio | PlainMessage<Ratio> | undefined, b: Ratio | PlainMessage<Ratio> | undefined): boolean {
    return proto3.util.equals(Ratio, a, b);
  }
}

